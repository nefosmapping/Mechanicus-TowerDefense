<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer 40K: Последний бой | KrimProduction & Огузок™</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', 'Arial', sans-serif;
            user-select: none;
        }

        body {
            background: #000;
            overflow: hidden;
            color: #fff;
            width: 100vw;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Заставка */
        #splash-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0033 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s;
        }

        .splash-title {
            font-size: 4em;
            color: #fff;
            text-shadow: 0 0 30px #9d00ff, 0 0 60px #9d00ff;
            letter-spacing: 0.3em;
            margin-bottom: 30px;
            animation: pulse 3s infinite;
            font-weight: 900;
        }

        .splash-subtitle {
            font-size: 1.5em;
            color: #ccc;
            opacity: 0.8;
            animation: fadeIn 3s ease-out;
            margin-bottom: 50px;
        }

        .splash-tm {
            position: absolute;
            bottom: 40px;
            right: 40px;
            font-size: 1em;
            color: #9d00ff;
            opacity: 0.6;
        }

        /* Кат-сцена */
        #cut-scene {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 900;
        }

        .cutscene-content {
            width: 90%;
            max-width: 800px;
            background: rgba(26, 0, 51, 0.9);
            border: 3px solid #9d00ff;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 0 100px rgba(157, 0, 255, 0.5);
        }

        .commander-card {
            display: flex;
            margin-bottom: 30px;
            border: 2px solid #9d00ff;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(74, 0, 109, 0.5);
        }

        .commander-image {
            width: 200px;
            height: 250px;
            background: linear-gradient(45deg, #1a0033, #4a006d);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            color: #9d00ff;
        }

        .commander-info {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .commander-name {
            font-size: 2em;
            color: #9d00ff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #9d00ff;
        }

        .commander-title {
            font-size: 1.2em;
            color: #00ffff;
            margin-bottom: 15px;
        }

        .dialogue-text {
            font-size: 1.1em;
            line-height: 1.6;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ffff;
        }

        .typing-indicator {
            width: 100%;
            height: 2px;
            background: #9d00ff;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }

        .typing-indicator::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: typing 2s infinite;
        }

        .skip-btn {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            border: none;
            color: white;
            padding: 10px 30px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            float: right;
            transition: all 0.3s;
        }

        .skip-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #9d00ff;
        }

        /* Игровой экран */
        #game-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 800;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        /* Игровой интерфейс */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 700;
        }

        .top-bar {
            position: absolute;
            top: 0;
            width: 100%;
            background: linear-gradient(to bottom, rgba(26, 0, 51, 0.9) 0%, transparent 100%);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
            pointer-events: all;
        }

        .resources {
            display: flex;
            gap: 30px;
            font-size: 1.2em;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #9d00ff;
        }

        .resource-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
        }

        .credits-icon { background: linear-gradient(45deg, gold, #ffd700); color: #000; }
        .power-icon { background: linear-gradient(45deg, #00ffff, #0088ff); color: #000; }
        .requisition-icon { background: linear-gradient(45deg, #ff4500, #ff8800); color: #000; }

        .wave-info {
            font-size: 1.2em;
            color: #ff4500;
            text-shadow: 0 0 15px #ff4500;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #ff4500;
        }

        /* Информационная панель */
        .info-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 300px;
            background: rgba(26, 0, 51, 0.9);
            border: 2px solid #9d00ff;
            border-radius: 10px;
            padding: 20px;
            pointer-events: all;
            backdrop-filter: blur(5px);
        }

        .info-title {
            color: #9d00ff;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-text {
            color: #ccc;
            font-size: 0.9em;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .mine-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(74, 0, 109, 0.3);
            border-radius: 5px;
        }

        .mine-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(157, 0, 255, 0.3);
        }

        .mine-name {
            color: #fff;
            font-size: 0.9em;
        }

        .mine-value {
            color: #00ff00;
            font-size: 0.9em;
        }

        /* Статус юнитов */
        .unit-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(74, 0, 109, 0.3);
            border-radius: 5px;
        }

        .unit-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(157, 0, 255, 0.3);
        }

        .unit-type {
            color: #fff;
            font-size: 0.9em;
        }

        .unit-count {
            color: #00ff00;
            font-size: 0.9em;
        }

        /* Меню строительства */
        .build-menu {
            position: absolute;
            bottom: -400px;
            left: 0;
            width: 100%;
            background: rgba(26, 0, 51, 0.95);
            border-top: 3px solid #9d00ff;
            padding: 20px;
            transition: bottom 0.5s ease-in-out;
            backdrop-filter: blur(10px);
            pointer-events: all;
            z-index: 750;
        }

        .build-menu.active {
            bottom: 0;
        }

        .build-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #9d00ff;
        }

        .build-title {
            font-size: 1.5em;
            color: #9d00ff;
        }

        .close-build-btn {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            border: none;
            color: white;
            padding: 8px 20px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .close-build-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #9d00ff;
        }

        .build-categories {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .category-btn {
            background: rgba(74, 0, 109, 0.5);
            border: 2px solid #9d00ff;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .category-btn.active {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            box-shadow: 0 0 15px #9d00ff;
        }

        .category-btn:hover {
            background: rgba(157, 0, 255, 0.3);
        }

        .build-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .build-item {
            background: linear-gradient(45deg, #2a0044, #4a006d);
            border: 2px solid #9d00ff;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .build-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(157, 0, 255, 0.5);
            background: linear-gradient(45deg, #4a006d, #9d00ff);
        }

        .build-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .build-item.disabled:hover {
            transform: none;
            box-shadow: none;
            background: linear-gradient(45deg, #2a0044, #4a006d);
        }

        .build-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #00ffff;
        }

        .build-name {
            color: #fff;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .build-cost {
            color: gold;
            font-size: 0.9em;
            font-weight: bold;
        }

        .build-requirements {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 5px;
        }

        /* Индикатор размещения */
        .drop-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 3px dashed #00ff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 600;
            display: none;
            animation: pulse 1s infinite;
        }

        /* Экран поражения */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 20px;
            border: 5px solid #ff4500;
            text-align: center;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 100px rgba(255, 69, 0, 0.5);
            backdrop-filter: blur(10px);
            min-width: 400px;
        }

        .game-over-title {
            font-size: 3em;
            color: #ff4500;
            text-shadow: 0 0 20px #ff4500;
            margin-bottom: 20px;
        }

        .stats {
            font-size: 1.3em;
            color: #fff;
            margin-bottom: 30px;
        }

        .restart-btn {
            background: linear-gradient(45deg, #ff4500, #ff8800);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
        }

        /* Загрузчик */
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 1100;
        }

        .loader-text {
            font-size: 1.5em;
            color: #9d00ff;
            margin-bottom: 20px;
        }

        .loader-progress-container {
            width: 400px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 2px solid #9d00ff;
        }

        .loader-progress {
            height: 100%;
            background: linear-gradient(90deg, #9d00ff, #00ffff);
            width: 0%;
            transition: width 0.3s;
        }

        .loader-percent {
            font-size: 1.2em;
            color: #00ffff;
            font-weight: bold;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 0, 51, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #9d00ff;
            font-size: 0.9em;
            color: #ccc;
            pointer-events: none;
        }

        /* Индикатор выбора */
        .selection-box {
            position: absolute;
            border: 2px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            display: none;
            pointer-events: none;
            z-index: 500;
        }

        /* Анимации */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes typing {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* HP бар */
        .hp-bar {
            position: absolute;
            width: 40px;
            height: 4px;
            background: #333;
            border: 1px solid #000;
            border-radius: 2px;
            overflow: hidden;
            pointer-events: none;
            z-index: 610;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            width: 100%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <!-- Основной контейнер -->
    <div id="game-container">
        <!-- Заставка -->
        <div id="splash-screen">
            <div class="splash-title">KRIMPRODUCTION</div>
            <div class="splash-subtitle">совместно с Огузок™</div>
            <div class="splash-tm">Warhammer 40 000 Universe</div>
        </div>

        <!-- Упрощенная кат-сцена -->
        <div id="cut-scene">
            <div class="cutscene-content">
                <div class="commander-card">
                    <div class="commander-image">
                        ⚙
                    </div>
                    <div class="commander-info">
                        <div class="commander-name">КОМАНДИР ЛЕКСУС</div>
                        <div class="commander-title">Адептус Механикус, Когорт VII</div>
                        <div class="commander-title">Командир корабля "Омниссия Прайм"</div>
                    </div>
                </div>
                
                <div id="dialogue-text" class="dialogue-text">
                    Вы - командир судна Адептус Механикус, дитя великой Омниссии. К большому сожалению, ваш корабль потерпел крушение на далёкой планете Доминика, населённой орками. И видимо, это будет ваш последний бой. Сражайтесь достойно, во имя Императора.<br><br>
                    Во мрачной тьме далёкого будущего есть только война...
                </div>
                
                <div class="typing-indicator"></div>
                <button class="skip-btn" id="skip-btn">ПРОПУСТИТЬ</button>
            </div>
        </div>

        <!-- Игровой экран -->
        <div id="game-screen">
            <canvas id="game-canvas"></canvas>
            
            <!-- Игровой интерфейс -->
            <div id="game-ui">
                <div class="top-bar">
                    <div class="resources">
                        <div class="resource">
                            <div class="resource-icon credits-icon">Ⱡ</div>
                            <span id="credits">2000</span>
                        </div>
                        <div class="resource">
                            <div class="resource-icon power-icon">⚡</div>
                            <span id="power">300/300</span>
                        </div>
                        <div class="resource">
                            <div class="resource-icon requisition-icon">⚙</div>
                            <span id="requisition">0/мин</span>
                        </div>
                        <div class="resource">
                            <div style="color: #00ffff; font-weight: bold;">Войска:</div>
                            <span id="unit-limit">0/20</span>
                        </div>
                    </div>
                    <div class="wave-info">
                        <div>ВОЛНА: <span id="wave">1</span></div>
                        <div>До следующей: <span id="wave-timer">30</span>с</div>
                    </div>
                </div>

                <!-- Информационная панель -->
                <div class="info-panel">
                    <div class="info-title">СТРАТЕГИЧЕСКИЙ ДИСПЛЕЙ</div>
                    <div class="info-text">• Выделение: ЛКМ + драг</div>
                    <div class="info-text">• Перемещение: Выделить + ПКМ на карту</div>
                    <div class="info-text">• Вращение стен: Выделить + R</div>
                    <div class="info-text">• Меню строительства: M</div>
                    
                    <div class="mine-status">
                        <div class="mine-item">
                            <span class="mine-name">Шахта Альфа</span>
                            <span class="mine-value" id="mine-1">Свободна</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">Шахта Бета</span>
                            <span class="mine-value" id="mine-2">Свободна</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">Шахта Гамма</span>
                            <span class="mine-value" id="mine-3">Свободна</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">Шахта Дельта</span>
                            <span class="mine-value" id="mine-4">Свободна</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">Шахта Эпсилон</span>
                            <span class="mine-value" id="mine-5">Свободна</span>
                        </div>
                    </div>
                    
                    <div class="unit-status">
                        <div class="unit-item">
                            <span class="unit-type">Казармы</span>
                            <span class="unit-count" id="barracks-count">0</span>
                        </div>
                        <div class="unit-item">
                            <span class="unit-type">Стены</span>
                            <span class="unit-count" id="walls-count">0</span>
                        </div>
                    </div>
                    
                    <div class="info-text" style="color: #ff4500; margin-top: 10px;">
                        База: <span id="base-hp">1000</span> HP
                    </div>
                </div>

                <!-- Индикатор размещения -->
                <div class="drop-indicator" id="drop-indicator"></div>

                <!-- Подсказки по управлению -->
                <div class="controls-hint">
                    WASD/Стрелки - движение камеры<br>
                    Средняя кнопка + движение - вращение<br>
                    Колесико - зум<br>
                    M - меню строительства<br>
                    R - вращение выбранного объекта
                </div>

                <!-- Бокс выделения -->
                <div class="selection-box" id="selection-box"></div>
            </div>
        </div>

        <!-- Меню строительства -->
        <div class="build-menu" id="build-menu">
            <div class="build-menu-header">
                <div class="build-title">МЕНЮ СТРОИТЕЛЬСТВА</div>
                <button class="close-build-btn" id="close-build-btn">ЗАКРЫТЬ (M)</button>
            </div>
            
            <div class="build-categories" id="build-categories">
                <button class="category-btn active" data-category="units">ВОЙСКА</button>
                <button class="category-btn" data-category="buildings">ЗДАНИЯ</button>
                <button class="category-btn" data-category="defenses">ОБОРОНА</button>
            </div>
            
            <div class="build-items" id="build-items">
                <!-- Содержимое будет заполняться динамически -->
            </div>
        </div>

        <!-- Экран поражения -->
        <div class="game-over" id="game-over">
            <div class="game-over-title">ПОРАЖЕНИЕ</div>
            <div class="stats">
                Вы продержались <span id="survived-waves">0</span> волн<br>
                Уничтожено врагов: <span id="enemies-killed">0</span><br>
                Добыто ресурсов: <span id="resources-earned">0</span> Ⱡ
            </div>
            <button class="restart-btn" id="restart-btn">НАЧАТЬ ЗАНОВО</button>
        </div>

        <!-- Загрузчик -->
        <div class="loader" id="loader">
            <div class="loader-text" id="loader-text">ИНИЦИАЛИЗАЦИЯ СИСТЕМ</div>
            <div class="loader-progress-container">
                <div class="loader-progress" id="loader-progress"></div>
            </div>
            <div class="loader-percent" id="loader-percent">0%</div>
        </div>
    </div>

    <!-- Подключаем Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Основной игровой код -->
    <script>
        // ==================== МЕНЕДЖЕР ЗАГРУЗКИ ====================
        class LoadManager {
            constructor() {
                this.progress = 0;
                this.totalAssets = 10;
                this.loadedAssets = 0;
            }

            show() {
                document.getElementById('loader').style.display = 'block';
            }

            hide() {
                document.getElementById('loader').style.display = 'none';
            }

            updateProgress() {
                this.loadedAssets++;
                this.progress = Math.min(100, Math.round((this.loadedAssets / this.totalAssets) * 100));
                document.getElementById('loader-progress').style.width = this.progress + '%';
                document.getElementById('loader-percent').textContent = this.progress + '%';
            }

            async load(description) {
                document.getElementById('loader-text').textContent = description;
                this.updateProgress();
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 200));
            }
        }

        // ==================== ЗАСТАВКА ====================
        class SplashScreen {
            static show() {
                return new Promise(resolve => {
                    const splash = document.getElementById('splash-screen');
                    splash.style.display = 'flex';
                    
                    setTimeout(() => {
                        splash.style.opacity = '0';
                        setTimeout(() => {
                            splash.style.display = 'none';
                            splash.style.opacity = '1';
                            resolve();
                        }, 1000);
                    }, 2000);
                });
            }
        }

        // ==================== КАТ-СЦЕНА ====================
        class Cutscene {
            constructor() {
                this.dialogueText = document.getElementById('dialogue-text');
                this.fullText = this.dialogueText.innerHTML;
                this.dialogueText.innerHTML = '';
                this.currentIndex = 0;
                this.isTyping = false;
                this.skipped = false;
                this.typingSpeed = 30;
                this.resolvePromise = null;
            }

            show() {
                return new Promise(resolve => {
                    this.resolvePromise = resolve;
                    document.getElementById('cut-scene').style.display = 'flex';
                    this.startTyping();
                    
                    document.getElementById('skip-btn').addEventListener('click', () => this.skip());
                });
            }

            startTyping() {
                this.isTyping = true;
                this.typeWriter();
            }

            typeWriter() {
                if (this.skipped || this.currentIndex >= this.fullText.length) {
                    this.isTyping = false;
                    setTimeout(() => {
                        this.hide();
                        if (this.resolvePromise) this.resolvePromise();
                    }, 1500);
                    return;
                }

                this.dialogueText.innerHTML = this.fullText.substring(0, this.currentIndex + 1);
                this.currentIndex++;

                setTimeout(() => this.typeWriter(), this.typingSpeed);
            }

            skip() {
                if (this.isTyping) {
                    this.skipped = true;
                    this.dialogueText.innerHTML = this.fullText;
                } else {
                    this.hide();
                    if (this.resolvePromise) this.resolvePromise();
                }
            }

            hide() {
                const cutScene = document.getElementById('cut-scene');
                cutScene.style.opacity = '0';
                setTimeout(() => {
                    cutScene.style.display = 'none';
                    cutScene.style.opacity = '1';
                }, 500);
            }
        }

        // ==================== ОСНОВНАЯ ИГРА ====================
        class Game {
            constructor() {
                this.loader = new LoadManager();
                this.cutscene = null;
                this.gameState = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.keys = {};
                this.mouseButtons = {};
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraPosition = new THREE.Vector3(0, 150, 200);
                this.cameraDistance = 200;
                this.cameraRotation = { x: -Math.PI / 4, y: 0 };
                this.isRotating = false;
                this.lastMousePosition = { x: 0, y: 0 };
                this.selectedUnits = [];
                this.dragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.rotationMode = false;
                
                this.gameLoopId = null;
                this.waveInterval = null;
                this.economyInterval = null;
                this.waveTimerInterval = null;
                this.buildQueue = [];
                this.placingBuilding = null;
                this.currentBuildCategory = 'units';
                
                this.hpBars = new Map();
                this.selectionBox = document.getElementById('selection-box');
            }

            static async start() {
                const game = new Game();
                await game.init();
                window.Game = game;
            }

            static restart() {
                if (window.Game) {
                    window.Game.cleanup();
                }
                location.reload();
            }

            cleanup() {
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                if (this.waveInterval) clearInterval(this.waveInterval);
                if (this.economyInterval) clearInterval(this.economyInterval);
                if (this.waveTimerInterval) clearInterval(this.waveTimerInterval);
                
                const skipBtn = document.getElementById('skip-btn');
                const restartBtn = document.getElementById('restart-btn');
                if (skipBtn) {
                    skipBtn.replaceWith(skipBtn.cloneNode(true));
                }
                if (restartBtn) {
                    restartBtn.replaceWith(restartBtn.cloneNode(true));
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
            }

            async init() {
                try {
                    console.log('Шаг 1: Заставка');
                    await SplashScreen.show();
                    
                    console.log('Шаг 2: Загрузчик');
                    this.loader.show();
                    
                    console.log('Шаг 3: Проверка Three.js');
                    if (typeof THREE === 'undefined') {
                        throw new Error('Three.js не загружен');
                    }
                    
                    console.log('Шаг 4: Инициализация Three.js');
                    await this.loader.load("Загрузка графического движка...");
                    await this.initThreeJS();
                    
                    console.log('Шаг 5: Инициализация игровых систем');
                    await this.loader.load("Настройка игровых систем...");
                    await this.initGameSystems();
                    
                    console.log('Шаг 6: Создание игрового мира');
                    await this.loader.load("Создание игрового мира...");
                    await this.createGameWorld();
                    
                    console.log('Шаг 7: Инициализация интерфейса');
                    await this.loader.load("Инициализация интерфейса...");
                    await this.initUI();
                    
                    console.log('Шаг 8: Финальная подготовка');
                    await this.loader.load("Финальная подготовка...");
                    
                    console.log('Шаг 9: Создание кат-сцены');
                    this.cutscene = new Cutscene();
                    
                    console.log('Шаг 10: Загрузка завершена');
                    this.loader.hide();
                    
                    console.log('Шаг 11: Кат-сцена');
                    await this.cutscene.show();
                    
                    console.log('Шаг 12: Запуск игры');
                    await this.startGameplay();
                    
                } catch (error) {
                    console.error('Ошибка загрузки:', error);
                    this.loader.hide();
                    this.showErrorMessage('Произошла ошибка при загрузке игры. Пожалуйста, обновите страницу.');
                }
            }

            showErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">ОШИБКА</h2>
                    <p style="margin-bottom: 20px;">${message}</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">ОБНОВИТЬ СТРАНИЦУ</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
            }

            async initThreeJS() {
                return new Promise((resolve) => {
                    try {
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x000000);
                        
                        this.camera = new THREE.PerspectiveCamera(
                            60,
                            window.innerWidth / window.innerHeight,
                            1,
                            2000
                        );
                        this.updateCameraPosition();
                        
                        const canvas = document.getElementById('game-canvas');
                        this.renderer = new THREE.WebGLRenderer({
                            canvas: canvas,
                            antialias: true
                        });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                        directionalLight.position.set(100, 200, 100);
                        directionalLight.castShadow = true;
                        this.scene.add(directionalLight);
                        
                        window.addEventListener('resize', () => this.onWindowResize());
                        
                        resolve();
                    } catch (error) {
                        console.error('Ошибка инициализации Three.js:', error);
                        throw error;
                    }
                });
            }

            updateCameraPosition() {
                const phi = this.cameraRotation.x;
                const theta = this.cameraRotation.y;
                
                const x = this.cameraTarget.x + this.cameraDistance * Math.sin(phi) * Math.sin(theta);
                const y = this.cameraTarget.y + this.cameraDistance * Math.cos(phi);
                const z = this.cameraTarget.z + this.cameraDistance * Math.sin(phi) * Math.cos(theta);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(this.cameraTarget);
            }

            async initGameSystems() {
                return new Promise((resolve) => {
                    this.gameState = {
                        credits: 2000,
                        power: 300,
                        powerMax: 300,
                        requisition: 0,
                        currentWave: 1,
                        waveTimer: 30,
                        baseHP: 1000,
                        baseMaxHP: 1000,
                        enemiesKilled: 0,
                        resourcesEarned: 0,
                        controlledMines: 0,
                        totalMines: 5,
                        mineIncome: 50,
                        unitLimit: 20,
                        currentUnits: 0,
                        barracksCount: 0,
                        wallsCount: 0,
                        gameTime: 0,
                        gameActive: false,
                        units: [],
                        enemies: [],
                        buildings: [],
                        walls: [],
                        mines: [],
                        selectedUnits: []
                    };
                    
                    this.unitsData = {
                        skitarii: { 
                            cost: 250, 
                            hp: 100,
                            maxHP: 100,
                            damage: 20, 
                            range: 40, 
                            attackSpeed: 1.5,
                            speed: 2.5,
                            sight: 60,
                            color: 0x9d00ff,
                            movable: true,
                            buildTime: 5000
                        },
                        turret: { 
                            cost: 500, 
                            hp: 300,
                            maxHP: 300,
                            damage: 50, 
                            range: 80, 
                            attackSpeed: 0.8,
                            speed: 0,
                            sight: 100,
                            color: 0xffd700,
                            movable: false,
                            buildTime: 10000
                        },
                        dreadnought: { 
                            cost: 1000, 
                            hp: 800,
                            maxHP: 800,
                            damage: 80, 
                            range: 25, 
                            attackSpeed: 1.0,
                            speed: 1.2,
                            sight: 50,
                            color: 0xff4500,
                            movable: true,
                            buildTime: 15000
                        }
                    };
                    
                    this.buildingsData = {
                        barracks: {
                            cost: 1000,
                            hp: 500,
                            maxHP: 500,
                            unitLimitIncrease: 10,
                            color: 0x4a006d,
                            size: { width: 10, depth: 8 },
                            buildTime: 20000
                        },
                        wall: {
                            cost: 200,
                            hp: 300,
                            maxHP: 300,
                            color: 0x666666,
                            size: { width: 5, depth: 2 },
                            buildTime: 5000
                        }
                    };
                    
                    this.enemyData = {
                        basic: {
                            hp: 100,
                            maxHP: 100,
                            damage: 15,
                            speed: 1.2,
                            sight: 50,
                            bounty: 50,
                            color: 0x00ff00
                        },
                        heavy: {
                            hp: 300,
                            maxHP: 300,
                            damage: 35,
                            speed: 0.8,
                            sight: 40,
                            bounty: 150,
                            color: 0xff8800
                        }
                    };
                    
                    resolve();
                });
            }

            async createGameWorld() {
                return new Promise((resolve) => {
                    const groundGeometry = new THREE.CircleGeometry(500, 128);
                    const groundMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a2e,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    this.scene.add(ground);
                    
                    this.createBase();
                    this.createMines();
                    this.createDecorations();
                    
                    resolve();
                });
            }

            createBase() {
                const baseGroup = new THREE.Group();
                
                const towerGeometry = new THREE.CylinderGeometry(20, 25, 40, 16);
                const towerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.y = 20;
                tower.castShadow = true;
                baseGroup.add(tower);
                
                const coreGeometry = new THREE.SphereGeometry(8, 16, 16);
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.core.position.y = 20;
                baseGroup.add(this.core);
                
                const platformGeometry = new THREE.CylinderGeometry(30, 35, 5, 16);
                const platformMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.6,
                    roughness: 0.4
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = 2.5;
                baseGroup.add(platform);
                
                this.scene.add(baseGroup);
                this.baseObject = baseGroup;
            }

            createMines() {
                const minePositions = [
                    { x: 200, z: 0, name: "Альфа" },
                    { x: -200, z: 0, name: "Бета" },
                    { x: 0, z: 200, name: "Гамма" },
                    { x: 0, z: -200, name: "Дельта" },
                    { x: 150, z: 150, name: "Эпсилон" }
                ];

                minePositions.forEach((pos, index) => {
                    const mineGroup = new THREE.Group();
                    
                    const platformGeometry = new THREE.CylinderGeometry(12, 15, 4, 8);
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.y = 2;
                    platform.castShadow = true;
                    mineGroup.add(platform);
                    
                    const drillGeometry = new THREE.CylinderGeometry(4, 3, 20, 8);
                    const drillMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff4500,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const drill = new THREE.Mesh(drillGeometry, drillMaterial);
                    drill.position.y = 12;
                    mineGroup.add(drill);
                    
                    mineGroup.position.set(pos.x, 0, pos.z);
                    this.scene.add(mineGroup);
                    
                    const mine = {
                        id: index,
                        group: mineGroup,
                        drill: drill,
                        x: pos.x,
                        z: pos.z,
                        name: pos.name,
                        controlled: false,
                        income: 50
                    };
                    
                    this.gameState.mines.push(mine);
                });
            }

            createDecorations() {
                for (let i = 0; i < 50; i++) {
                    const size = 3 + Math.random() * 12;
                    const rockGeometry = new THREE.DodecahedronGeometry(size, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        roughness: 0.8
                    });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 350;
                    rock.position.x = Math.cos(angle) * distance;
                    rock.position.z = Math.sin(angle) * distance;
                    rock.position.y = size / 2;
                    
                    rock.castShadow = true;
                    this.scene.add(rock);
                }
            }

            async initUI() {
                return new Promise((resolve) => {
                    document.getElementById('restart-btn').addEventListener('click', () => Game.restart());
                    
                    this.setupControls();
                    this.setupBuildMenu();
                    
                    resolve();
                });
            }

            setupControls() {
                window.addEventListener('keydown', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    const key = e.key.toLowerCase();
                    this.keys[key] = true;
                    
                    // Меню строительства по клавише M
                    if (key === 'm') {
                        e.preventDefault();
                        const buildMenu = document.getElementById('build-menu');
                        buildMenu.classList.toggle('active');
                        this.placingBuilding = null;
                    }
                    
                    // Вращение выбранных объектов по клавише R
                    if (key === 'r' && this.selectedUnits.length > 0) {
                        e.preventDefault();
                        this.rotateSelectedUnits();
                    }
                    
                    // Отмена размещения по Escape
                    if (key === 'escape') {
                        this.placingBuilding = null;
                        const indicator = document.getElementById('drop-indicator');
                        indicator.style.display = 'none';
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (!this.gameState?.gameActive) return;
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                const canvas = document.getElementById('game-canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (e.button === 0) { // Левая кнопка мыши
                        if (this.placingBuilding) {
                            this.placeBuilding(e);
                        } else {
                            this.dragging = true;
                            this.dragStart.x = e.clientX;
                            this.dragStart.y = e.clientY;
                            this.selectionBox.style.display = 'none';
                        }
                    }
                    
                    if (e.button === 1) { // Средняя кнопка
                        e.preventDefault();
                        this.isRotating = true;
                        this.lastMousePosition.x = e.clientX;
                        this.lastMousePosition.y = e.clientY;
                        canvas.style.cursor = 'grabbing';
                    }
                    
                    if (e.button === 2) { // Правая кнопка
                        e.preventDefault();
                        this.moveSelectedUnits(e);
                    }
                    
                    this.mouseButtons[e.button] = true;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (this.dragging) {
                        const currentX = e.clientX;
                        const currentY = e.clientY;
                        
                        this.selectionBox.style.left = Math.min(this.dragStart.x, currentX) + 'px';
                        this.selectionBox.style.top = Math.min(this.dragStart.y, currentY) + 'px';
                        this.selectionBox.style.width = Math.abs(currentX - this.dragStart.x) + 'px';
                        this.selectionBox.style.height = Math.abs(currentY - this.dragStart.y) + 'px';
                        this.selectionBox.style.display = 'block';
                    }
                    
                    if (this.isRotating) {
                        const deltaX = e.clientX - this.lastMousePosition.x;
                        const deltaY = e.clientY - this.lastMousePosition.y;
                        
                        this.cameraRotation.y -= deltaX * 0.005;
                        this.cameraRotation.x -= deltaY * 0.005;
                        
                        this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(-0.1, this.cameraRotation.x));
                        
                        this.updateCameraPosition();
                        this.lastMousePosition.x = e.clientX;
                        this.lastMousePosition.y = e.clientY;
                    }
                    
                    if (this.placingBuilding) {
                        const indicator = document.getElementById('drop-indicator');
                        indicator.style.left = (e.clientX - 20) + 'px';
                        indicator.style.top = (e.clientY - 20) + 'px';
                    }
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (e.button === 0 && this.dragging) {
                        this.dragging = false;
                        this.selectUnitsInBox(e);
                        this.selectionBox.style.display = 'none';
                    }
                    
                    if (e.button === 1) {
                        this.isRotating = false;
                        canvas.style.cursor = 'default';
                    }
                    
                    this.mouseButtons[e.button] = false;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    if (!this.gameState?.gameActive) return;
                    e.preventDefault();
                    
                    const zoomSpeed = 15;
                    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                    
                    this.cameraDistance = Math.max(50, Math.min(500, this.cameraDistance + delta));
                    this.updateCameraPosition();
                });
                
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            setupBuildMenu() {
                const closeBtn = document.getElementById('close-build-btn');
                closeBtn.addEventListener('click', () => {
                    const buildMenu = document.getElementById('build-menu');
                    buildMenu.classList.remove('active');
                    this.placingBuilding = null;
                });
                
                const categories = document.querySelectorAll('.category-btn');
                categories.forEach(btn => {
                    btn.addEventListener('click', () => {
                        categories.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentBuildCategory = btn.dataset.category;
                        this.updateBuildItems();
                    });
                });
                
                this.updateBuildItems();
            }

            updateBuildItems() {
                const buildItems = document.getElementById('build-items');
                buildItems.innerHTML = '';
                
                let items = [];
                
                switch(this.currentBuildCategory) {
                    case 'units':
                        items = [
                            { type: 'skitarii', name: 'Скитарий', cost: 250, icon: '⚔', requirements: '' },
                            { type: 'turret', name: 'Турель', cost: 500, icon: '☢', requirements: '' },
                            { type: 'dreadnought', name: 'Дредноут', cost: 1000, icon: '⚙', requirements: '' }
                        ];
                        break;
                    case 'buildings':
                        items = [
                            { type: 'barracks', name: 'Казармы', cost: 1000, icon: '🏛', requirements: 'Увеличивает лимит войск на 10' }
                        ];
                        break;
                    case 'defenses':
                        items = [
                            { type: 'wall', name: 'Стена', cost: 200, icon: '🧱', requirements: 'Блокирует проход врагам' }
                        ];
                        break;
                }
                
                items.forEach(item => {
                    const canAfford = this.gameState.credits >= item.cost;
                    const canBuild = item.type === 'skitarii' || item.type === 'dreadnought' ? 
                        this.gameState.currentUnits < this.gameState.unitLimit : true;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `build-item ${!canAfford || !canBuild ? 'disabled' : ''}`;
                    itemDiv.innerHTML = `
                        <div class="build-icon">${item.icon}</div>
                        <div class="build-name">${item.name}</div>
                        <div class="build-cost">${item.cost} Ⱡ</div>
                        ${item.requirements ? `<div class="build-requirements">${item.requirements}</div>` : ''}
                    `;
                    
                    if (canAfford && canBuild) {
                        itemDiv.addEventListener('click', () => {
                            this.startPlacingBuilding(item.type);
                            document.getElementById('build-menu').classList.remove('active');
                        });
                    }
                    
                    buildItems.appendChild(itemDiv);
                });
            }

            startPlacingBuilding(type) {
                this.placingBuilding = type;
                const indicator = document.getElementById('drop-indicator');
                indicator.style.display = 'block';
                indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
            }

            placeBuilding(e) {
                if (!this.placingBuilding) return;
                
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    const distanceToBase = intersectionPoint.distanceTo(new THREE.Vector3(0, 0, 0));
                    
                    if (distanceToBase > 30 && distanceToBase < 450) {
                        if (this.placingBuilding === 'wall') {
                            this.createWall(intersectionPoint.x, intersectionPoint.z);
                        } else if (this.placingBuilding === 'barracks') {
                            this.createBarracks(intersectionPoint.x, intersectionPoint.z);
                        } else {
                            this.createUnit(this.placingBuilding, intersectionPoint.x, intersectionPoint.z);
                        }
                    } else {
                        alert('Нельзя строить слишком близко к базе или слишком далеко!');
                    }
                }
                
                this.placingBuilding = null;
                const indicator = document.getElementById('drop-indicator');
                indicator.style.display = 'none';
            }

            createUnit(type, x, z) {
                const unitData = this.unitsData[type];
                if (!unitData) return null;
                
                if (this.gameState.credits < unitData.cost) {
                    alert('Недостаточно кредитов!');
                    return null;
                }
                
                if (this.gameState.currentUnits >= this.gameState.unitLimit) {
                    alert('Достигнут лимит войск! Постройте казармы для увеличения лимита.');
                    return null;
                }
                
                let geometry;
                switch(type) {
                    case 'skitarii':
                        geometry = new THREE.CylinderGeometry(2, 2, 5, 8);
                        break;
                    case 'turret':
                        geometry = new THREE.CylinderGeometry(3, 4, 6, 8);
                        break;
                    case 'dreadnought':
                        geometry = new THREE.BoxGeometry(4, 6, 4);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(3, 3, 3);
                }
                
                const material = new THREE.MeshStandardMaterial({
                    color: unitData.color,
                    metalness: 0.7,
                    roughness: 0.3
                });
                
                const unit = new THREE.Mesh(geometry, material);
                unit.position.set(x, 2, z);
                unit.castShadow = true;
                unit.receiveShadow = true;
                
                unit.userData = {
                    type: type,
                    hp: unitData.hp,
                    maxHP: unitData.hp,
                    damage: unitData.damage,
                    range: unitData.range,
                    attackSpeed: unitData.attackSpeed,
                    speed: unitData.speed,
                    sight: unitData.sight,
                    lastAttack: 0,
                    movable: unitData.movable,
                    target: null,
                    destination: null,
                    rotation: 0,
                    isMoving: false
                };
                
                this.scene.add(unit);
                this.gameState.units.push(unit);
                this.gameState.currentUnits++;
                this.gameState.credits -= unitData.cost;
                
                this.updateUI();
                this.createHPBar(unit);
                
                return unit;
            }

            createWall(x, z) {
                const wallData = this.buildingsData.wall;
                
                if (this.gameState.credits < wallData.cost) {
                    alert('Недостаточно кредитов!');
                    return;
                }
                
                const geometry = new THREE.BoxGeometry(wallData.size.width, 4, wallData.size.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: wallData.color,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, 2, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                
                wall.userData = {
                    type: 'wall',
                    hp: wallData.hp,
                    maxHP: wallData.hp,
                    rotation: 0
                };
                
                this.scene.add(wall);
                this.gameState.walls.push(wall);
                this.gameState.wallsCount++;
                this.gameState.credits -= wallData.cost;
                
                this.updateUI();
                this.createHPBar(wall);
                
                return wall;
            }

            createBarracks(x, z) {
                const barracksData = this.buildingsData.barracks;
                
                if (this.gameState.credits < barracksData.cost) {
                    alert('Недостаточно кредитов!');
                    return;
                }
                
                const geometry = new THREE.BoxGeometry(barracksData.size.width, 6, barracksData.size.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: barracksData.color,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const barracks = new THREE.Mesh(geometry, material);
                barracks.position.set(x, 3, z);
                barracks.castShadow = true;
                barracks.receiveShadow = true;
                
                barracks.userData = {
                    type: 'barracks',
                    hp: barracksData.hp,
                    maxHP: barracksData.hp
                };
                
                this.scene.add(barracks);
                this.gameState.buildings.push(barracks);
                this.gameState.barracksCount++;
                this.gameState.unitLimit += barracksData.unitLimitIncrease;
                this.gameState.credits -= barracksData.cost;
                
                this.updateUI();
                this.createHPBar(barracks);
                
                return barracks;
            }

            createHPBar(object) {
                const hpBar = document.createElement('div');
                hpBar.className = 'hp-bar';
                
                const hpFill = document.createElement('div');
                hpFill.className = 'hp-fill';
                hpBar.appendChild(hpFill);
                
                document.getElementById('game-ui').appendChild(hpBar);
                this.hpBars.set(object, { element: hpBar, fill: hpFill });
            }

            updateHPBar(object) {
                const hpBar = this.hpBars.get(object);
                if (!hpBar || !object.userData) return;
                
                const percent = (object.userData.hp / object.userData.maxHP) * 100;
                hpBar.fill.style.width = percent + '%';
                
                const position = object.position.clone();
                position.y += 5;
                
                const vector = position.project(this.camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                hpBar.element.style.left = (x - 20) + 'px';
                hpBar.element.style.top = (y - 30) + 'px';
                hpBar.element.style.display = 'block';
            }

            selectUnitsInBox(e) {
                const rect = e.target.getBoundingClientRect();
                const x1 = Math.min(this.dragStart.x, e.clientX);
                const x2 = Math.max(this.dragStart.x, e.clientX);
                const y1 = Math.min(this.dragStart.y, e.clientY);
                const y2 = Math.max(this.dragStart.y, e.clientY);
                
                this.clearSelection();
                
                this.gameState.units.forEach(unit => {
                    const position = unit.position.clone().project(this.camera);
                    const screenX = (position.x * 0.5 + 0.5) * window.innerWidth;
                    const screenY = (-position.y * 0.5 + 0.5) * window.innerHeight;
                    
                    if (screenX >= x1 && screenX <= x2 && screenY >= y1 && screenY <= y2) {
                        this.selectUnit(unit);
                    }
                });
            }

            clearSelection() {
                this.selectedUnits.forEach(unit => {
                    if (unit.material && unit.material.emissive) {
                        unit.material.emissive.setHex(0x000000);
                    }
                });
                this.selectedUnits = [];
            }

            selectUnit(unit) {
                if (unit.userData.type === 'wall' || unit.userData.type === 'barracks') {
                    this.clearSelection();
                }
                
                this.selectedUnits.push(unit);
                if (unit.material && unit.material.emissive) {
                    unit.material.emissive.setHex(0x00ff00);
                    unit.material.emissiveIntensity = 0.3;
                }
            }

            rotateSelectedUnits() {
                this.selectedUnits.forEach(unit => {
                    if (unit.userData.type === 'wall') {
                        unit.rotation.y += Math.PI / 2;
                    }
                });
            }

            moveSelectedUnits(e) {
                if (this.selectedUnits.length === 0) return;
                
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    const distanceToBase = intersectionPoint.distanceTo(new THREE.Vector3(0, 0, 0));
                    
                    if (distanceToBase > 30 && distanceToBase < 450) {
                        this.selectedUnits.forEach(unit => {
                            if (unit.userData.movable) {
                                unit.userData.destination = intersectionPoint.clone();
                                unit.userData.isMoving = true;
                                
                                const offsetX = (Math.random() - 0.5) * 10;
                                const offsetZ = (Math.random() - 0.5) * 10;
                                unit.userData.destination.x += offsetX;
                                unit.userData.destination.z += offsetZ;
                            }
                        });
                        
                        this.createMoveEffect(intersectionPoint);
                    }
                }
            }

            createMoveEffect(position) {
                const ringGeometry = new THREE.RingGeometry(5, 7, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(position.x, 0.5, position.z);
                ring.rotation.x = -Math.PI / 2;
                this.scene.add(ring);
                
                let scale = 1;
                const animate = () => {
                    scale += 0.05;
                    ring.scale.set(scale, scale, scale);
                    ring.material.opacity -= 0.05;
                    
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(ring);
                    }
                };
                animate();
            }

            async startGameplay() {
                return new Promise((resolve) => {
                    document.getElementById('game-screen').style.display = 'block';
                    this.gameState.gameActive = true;
                    
                    this.updateUI();
                    
                    this.startGameLoop();
                    this.startWaves();
                    this.startEconomy();
                    
                    resolve();
                });
            }

            startGameLoop() {
                const animate = () => {
                    if (!this.gameState?.gameActive) return;
                    
                    this.gameState.gameTime++;
                    
                    this.updateCameraMovement();
                    this.updateAnimations();
                    this.updateUnits();
                    this.updateEnemies();
                    this.updateBuildings();
                    this.updateHPBars();
                    
                    if (this.gameState.baseHP <= 0) {
                        this.endGame();
                        return;
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                    this.gameLoopId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            updateCameraMovement() {
                const moveSpeed = 5;
                const forward = new THREE.Vector3(
                    Math.sin(this.cameraRotation.y),
                    0,
                    Math.cos(this.cameraRotation.y)
                ).normalize();
                
                const right = new THREE.Vector3(
                    Math.cos(this.cameraRotation.y),
                    0,
                    -Math.sin(this.cameraRotation.y)
                ).normalize();
                
                if (this.keys['w'] || this.keys['arrowup']) {
                    this.cameraTarget.add(forward.clone().multiplyScalar(moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['s'] || this.keys['arrowdown']) {
                    this.cameraTarget.add(forward.clone().multiplyScalar(-moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['a'] || this.keys['arrowleft']) {
                    this.cameraTarget.add(right.clone().multiplyScalar(-moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    this.cameraTarget.add(right.clone().multiplyScalar(moveSpeed));
                    this.updateCameraPosition();
                }
                
                this.cameraTarget.x = Math.max(-400, Math.min(400, this.cameraTarget.x));
                this.cameraTarget.z = Math.max(-400, Math.min(400, this.cameraTarget.z));
            }

            updateAnimations() {
                if (this.core) {
                    const pulse = Math.sin(this.gameState.gameTime * 0.05) * 0.1 + 0.9;
                    this.core.scale.setScalar(pulse);
                }
                
                this.gameState.mines.forEach(mine => {
                    if (mine.drill) {
                        mine.drill.rotation.y += 0.02;
                        if (mine.controlled) {
                            const bounce = Math.sin(this.gameState.gameTime * 0.1 + mine.id) * 2;
                            mine.drill.position.y = 12 + bounce;
                        }
                    }
                });
            }

            updateUnits() {
                for (let i = this.gameState.units.length - 1; i >= 0; i--) {
                    const unit = this.gameState.units[i];
                    
                    if (unit.userData.hp <= 0) {
                        this.scene.remove(unit);
                        this.gameState.units.splice(i, 1);
                        this.gameState.currentUnits--;
                        
                        const hpBar = this.hpBars.get(unit);
                        if (hpBar) {
                            hpBar.element.remove();
                            this.hpBars.delete(unit);
                        }
                        continue;
                    }
                    
                    if (unit.userData.isMoving && unit.userData.destination) {
                        const dx = unit.userData.destination.x - unit.position.x;
                        const dz = unit.userData.destination.z - unit.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 1) {
                            unit.position.x += (dx / distance) * unit.userData.speed;
                            unit.position.z += (dz / distance) * unit.userData.speed;
                            
                            if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                                unit.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            unit.userData.isMoving = false;
                            unit.userData.destination = null;
                        }
                    }
                    
                    this.unitAttack(unit);
                }
            }

            unitAttack(unit) {
                const currentTime = this.gameState.gameTime;
                const attackCooldown = 60 / unit.userData.attackSpeed;
                
                if (currentTime - unit.userData.lastAttack < attackCooldown) return;
                
                let nearestEnemy = null;
                let nearestDistance = unit.userData.sight;
                
                this.gameState.enemies.forEach(enemy => {
                    const distance = unit.position.distanceTo(enemy.position);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy && nearestDistance <= unit.userData.range) {
                    nearestEnemy.userData.hp -= unit.userData.damage;
                    unit.userData.lastAttack = currentTime;
                    
                    if (nearestEnemy.userData.hp <= 0) {
                        this.gameState.credits += nearestEnemy.userData.bounty;
                        this.gameState.enemiesKilled++;
                        this.gameState.resourcesEarned += nearestEnemy.userData.bounty;
                    }
                    
                    this.createAttackEffect(unit, nearestEnemy);
                }
            }

            updateEnemies() {
                for (let i = this.gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.gameState.enemies[i];
                    
                    if (enemy.userData.hp <= 0) {
                        this.scene.remove(enemy);
                        this.gameState.enemies.splice(i, 1);
                        continue;
                    }
                    
                    let target = null;
                    let targetDistance = enemy.userData.sight;
                    
                    this.gameState.units.forEach(unit => {
                        const distance = enemy.position.distanceTo(unit.position);
                        if (distance < targetDistance) {
                            targetDistance = distance;
                            target = unit;
                        }
                    });
                    
                    this.gameState.walls.forEach(wall => {
                        const distance = enemy.position.distanceTo(wall.position);
                        if (distance < targetDistance) {
                            targetDistance = distance;
                            target = wall;
                        }
                    });
                    
                    if (target) {
                        const dx = target.position.x - enemy.position.x;
                        const dz = target.position.z - enemy.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 2) {
                            enemy.position.x += (dx / distance) * enemy.userData.speed;
                            enemy.position.z += (dz / distance) * enemy.userData.speed;
                        } else if (target.userData.type !== 'wall') {
                            target.userData.hp -= enemy.userData.damage;
                        }
                        
                        enemy.rotation.y = Math.atan2(dx, dz);
                    } else {
                        const dx = 0 - enemy.position.x;
                        const dz = 0 - enemy.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 15) {
                            enemy.position.x += (dx / distance) * enemy.userData.speed;
                            enemy.position.z += (dz / distance) * enemy.userData.speed;
                        } else {
                            this.gameState.baseHP -= enemy.userData.damage;
                            this.createDamageEffect(0, 20, 0);
                            this.updateUI();
                        }
                    }
                }
            }

            updateBuildings() {
                this.gameState.walls.forEach(wall => {
                    if (wall.userData.hp <= 0) {
                        this.scene.remove(wall);
                        this.gameState.walls = this.gameState.walls.filter(w => w !== wall);
                        this.gameState.wallsCount--;
                        
                        const hpBar = this.hpBars.get(wall);
                        if (hpBar) {
                            hpBar.element.remove();
                            this.hpBars.delete(wall);
                        }
                    }
                });
            }

            updateHPBars() {
                [...this.gameState.units, ...this.gameState.walls, ...this.gameState.buildings].forEach(obj => {
                    this.updateHPBar(obj);
                });
            }

            createAttackEffect(attacker, target) {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    attacker.position.clone(),
                    target.position.clone()
                ]);
                
                const material = new THREE.LineBasicMaterial({
                    color: attacker.userData.type === 'turret' ? 0xffd700 : 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                
                setTimeout(() => this.scene.remove(line), 100);
            }

            createDamageEffect(x, y, z) {
                const geometry = new THREE.SphereGeometry(5, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                this.scene.add(sphere);
                
                let scale = 1;
                const animate = () => {
                    scale += 0.1;
                    sphere.scale.setScalar(scale);
                    sphere.material.opacity -= 0.05;
                    
                    if (sphere.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(sphere);
                    }
                };
                animate();
            }

            startWaves() {
                setTimeout(() => this.spawnWave(), 10000);
                
                this.waveInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    this.gameState.currentWave++;
                    this.gameState.waveTimer = 60;
                    this.spawnWave();
                    
                }, 60000);
                
                this.waveTimerInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (this.gameState.waveTimer > 0) {
                        this.gameState.waveTimer--;
                        document.getElementById('wave-timer').textContent = this.gameState.waveTimer;
                    }
                }, 1000);
            }

            spawnWave() {
                const enemyCount = 3 + Math.floor(this.gameState.currentWave * 1.5);
                const heavyCount = Math.floor(this.gameState.currentWave / 3);
                
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (!this.gameState?.gameActive) return;
                        
                        const isHeavy = i < heavyCount;
                        this.spawnEnemy(isHeavy ? 'heavy' : 'basic');
                    }, i * 800);
                }
                
                document.getElementById('wave').textContent = this.gameState.currentWave;
            }

            spawnEnemy(type) {
                const enemyType = this.enemyData[type] || this.enemyData.basic;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 480;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const geometry = new THREE.BoxGeometry(4, 5, 4);
                const material = new THREE.MeshStandardMaterial({
                    color: enemyType.color,
                    metalness: 0.5,
                    roughness: 0.5
                });
                
                const enemy = new THREE.Mesh(geometry, material);
                enemy.position.set(x, 2.5, z);
                enemy.castShadow = true;
                
                enemy.userData = {
                    type: type,
                    hp: enemyType.hp,
                    maxHP: enemyType.hp,
                    damage: enemyType.damage,
                    speed: enemyType.speed,
                    sight: enemyType.sight,
                    bounty: enemyType.bounty
                };
                
                this.scene.add(enemy);
                this.gameState.enemies.push(enemy);
                
                this.createHPBar(enemy);
            }

            startEconomy() {
                this.economyInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    const income = this.gameState.controlledMines * this.gameState.mineIncome;
                    this.gameState.credits += income;
                    this.gameState.resourcesEarned += income;
                    
                    this.gameState.power = Math.min(
                        this.gameState.powerMax,
                        this.gameState.power + 10
                    );
                    
                    document.getElementById('requisition').textContent = 
                        `+${this.gameState.controlledMines * this.gameState.mineIncome}/мин`;
                    
                    this.updateUI();
                    
                }, 10000);
            }

            updateUI() {
                document.getElementById('credits').textContent = this.gameState.credits;
                document.getElementById('power').textContent = 
                    `${this.gameState.power}/${this.gameState.powerMax}`;
                document.getElementById('base-hp').textContent = this.gameState.baseHP;
                document.getElementById('unit-limit').textContent = 
                    `${this.gameState.currentUnits}/${this.gameState.unitLimit}`;
                document.getElementById('barracks-count').textContent = this.gameState.barracksCount;
                document.getElementById('walls-count').textContent = this.gameState.wallsCount;
                
                this.updateBuildItems();
                
                this.gameState.mines.forEach(mine => {
                    const element = document.getElementById(`mine-${mine.id + 1}`);
                    if (element) {
                        element.textContent = mine.controlled ? 'Контролируется' : 'Свободна';
                        element.style.color = mine.controlled ? '#00ff00' : '#fff';
                    }
                });
            }

            onWindowResize() {
                if (!this.camera || !this.renderer) return;
                
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            endGame() {
                this.gameState.gameActive = false;
                
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                    this.gameLoopId = null;
                }
                if (this.waveInterval) clearInterval(this.waveInterval);
                if (this.economyInterval) clearInterval(this.economyInterval);
                if (this.waveTimerInterval) clearInterval(this.waveTimerInterval);
                
                document.getElementById('survived-waves').textContent = this.gameState.currentWave;
                document.getElementById('enemies-killed').textContent = this.gameState.enemiesKilled;
                document.getElementById('resources-earned').textContent = this.gameState.resourcesEarned;
                
                document.getElementById('game-over').style.display = 'block';
            }
        }

        window.addEventListener('load', () => {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">ОШИБКА ВЕБ-ГРАФИКИ</h2>
                    <p style="margin-bottom: 20px;">Ваш браузер не поддерживает WebGL. Игра не может быть запущена.</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">ПОПРОБОВАТЬ СНОВА</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
                return;
            }
            
            Game.start().catch(error => {
                console.error('Ошибка запуска игры:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">ОШИБКА ЗАГРУЗКИ</h2>
                    <p style="margin-bottom: 20px;">Не удалось загрузить игру. Пожалуйста, обновите страницу.</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">ОБНОВИТЬ СТРАНИЦУ</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
            });
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer 40K: –ü–æ—Å–ª–µ–¥–Ω–∏–π –±–æ–π | KrimProduction & –û–≥—É–∑–æ–∫‚Ñ¢ & –ê–ª–µ–∫—Å–µ–π¬Æ</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', 'Arial', sans-serif;
            user-select: none;
        }

        body {
            background: #000;
            overflow: hidden;
            color: #fff;
            width: 100vw;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* –ó–∞—Å—Ç–∞–≤–∫–∞ */
        #splash-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0033 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s;
        }

        .splash-title {
            font-size: 4em;
            color: #fff;
            text-shadow: 0 0 30px #9d00ff, 0 0 60px #9d00ff;
            letter-spacing: 0.3em;
            margin-bottom: 30px;
            animation: pulse 3s infinite;
            font-weight: 900;
        }

        .splash-subtitle {
            font-size: 1.5em;
            color: #ccc;
            opacity: 0.8;
            animation: fadeIn 3s ease-out;
            margin-bottom: 50px;
        }

        .splash-tm {
            position: absolute;
            bottom: 40px;
            right: 40px;
            font-size: 1em;
            color: #9d00ff;
            opacity: 0.6;
        }

        /* –ö–∞—Ç-—Å—Ü–µ–Ω–∞ */
        #cut-scene {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 900;
        }

        .cutscene-content {
            width: 90%;
            max-width: 800px;
            background: rgba(26, 0, 51, 0.9);
            border: 3px solid #9d00ff;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 0 100px rgba(157, 0, 255, 0.5);
        }

        .commander-card {
            display: flex;
            margin-bottom: 30px;
            border: 2px solid #9d00ff;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(74, 0, 109, 0.5);
        }

        .commander-image {
            width: 200px;
            height: 250px;
            background: linear-gradient(45deg, #1a0033, #4a006d);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            color: #9d00ff;
        }

        .commander-info {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .commander-name {
            font-size: 2em;
            color: #9d00ff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #9d00ff;
        }

        .commander-title {
            font-size: 1.2em;
            color: #00ffff;
            margin-bottom: 15px;
        }

        .dialogue-text {
            font-size: 1.1em;
            line-height: 1.6;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ffff;
        }

        .typing-indicator {
            width: 100%;
            height: 2px;
            background: #9d00ff;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }

        .typing-indicator::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: typing 2s infinite;
        }

        .skip-btn {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            border: none;
            color: white;
            padding: 10px 30px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            float: right;
            transition: all 0.3s;
        }

        .skip-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #9d00ff;
        }

        /* –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        #game-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 800;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        /* –ò–≥—Ä–æ–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 700;
        }

        .top-bar {
            position: absolute;
            top: 0;
            width: 100%;
            background: linear-gradient(to bottom, rgba(26, 0, 51, 0.9) 0%, transparent 100%);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
            pointer-events: all;
            transition: opacity 0.3s;
        }

        .top-bar.hidden {
            opacity: 0.3;
        }

        .resources {
            display: flex;
            gap: 30px;
            font-size: 1.2em;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #9d00ff;
        }

        .resource-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
        }

        .credits-icon { background: linear-gradient(45deg, gold, #ffd700); color: #000; }
        .power-icon { background: linear-gradient(45deg, #00ffff, #0088ff); color: #000; }
        .requisition-icon { background: linear-gradient(45deg, #ff4500, #ff8800); color: #000; }

        .wave-info {
            font-size: 1.2em;
            color: #ff4500;
            text-shadow: 0 0 15px #ff4500;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #ff4500;
        }

        /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º */
        .ui-controls {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: all;
            z-index: 850;
        }

        .ui-toggle-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #4a006d, #9d00ff);
            border: 2px solid #9d00ff;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 1.2em;
        }

        .ui-toggle-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(157, 0, 255, 0.8);
        }

        .ui-toggle-btn.active {
            background: linear-gradient(45deg, #00ff00, #008800);
            border-color: #00ff00;
        }

        .ui-toggle-btn.inactive {
            background: linear-gradient(45deg, #ff4500, #ff8800);
            border-color: #ff4500;
        }

        /* –ö–Ω–æ–ø–∫–∏ –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ */
        .quick-commands {
            position: absolute;
            bottom: 120px;
            left: 20px;
            display: flex;
            gap: 10px;
            pointer-events: all;
            transition: opacity 0.3s;
        }

        .quick-commands.hidden {
            opacity: 0.3;
        }

        .quick-command-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #4a006d, #9d00ff);
            border: 2px solid #9d00ff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 1.5em;
        }

        .quick-command-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.8);
        }

        /* –ö–Ω–æ–ø–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è/—Å–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ */
        .build-menu-toggle {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            border: 3px solid #9d00ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: all;
            z-index: 751;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.5);
        }

        .build-menu-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(157, 0, 255, 0.8);
        }

        .build-menu-toggle-icon {
            font-size: 2.5em;
            color: #fff;
            transition: transform 0.3s;
        }

        .build-menu-toggle.active .build-menu-toggle-icon {
            transform: rotate(180deg);
        }

        /* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å */
        .info-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 300px;
            background: rgba(26, 0, 51, 0.9);
            border: 2px solid #9d00ff;
            border-radius: 10px;
            padding: 20px;
            pointer-events: all;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }

        .info-panel.hidden {
            opacity: 0.3;
        }

        .info-title {
            color: #9d00ff;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-text {
            color: #ccc;
            font-size: 0.9em;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .mine-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(74, 0, 109, 0.3);
            border-radius: 5px;
        }

        .mine-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(157, 0, 255, 0.3);
        }

        .mine-name {
            color: #fff;
            font-size: 0.9em;
        }

        .mine-value {
            color: #00ff00;
            font-size: 0.9em;
        }

        /* –°—Ç–∞—Ç—É—Å —é–Ω–∏—Ç–æ–≤ */
        .unit-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(74, 0, 109, 0.3);
            border-radius: 5px;
        }

        .unit-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(157, 0, 255, 0.3);
        }

        .unit-type {
            color: #fff;
            font-size: 0.9em;
        }

        .unit-count {
            color: #00ff00;
            font-size: 0.9em;
        }

        /* –ü–∞–Ω–µ–ª—å –≤—ã–±–æ—Ä–∞ */
        .selection-panel {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 0, 51, 0.9);
            border: 2px solid #9d00ff;
            border-radius: 10px;
            padding: 15px;
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            pointer-events: all;
            backdrop-filter: blur(5px);
            z-index: 800;
        }

        .selection-panel.active {
            display: grid;
        }

        .selected-unit {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #4a006d, #9d00ff);
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .selected-unit-icon {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .selected-unit-hp {
            font-size: 0.7em;
            color: #ff4500;
        }

        /* –ú–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ */
        .build-menu {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(26, 0, 51, 0.95);
            border-top: 3px solid #9d00ff;
            padding: 20px;
            backdrop-filter: blur(10px);
            pointer-events: all;
            z-index: 749;
            transition: transform 0.5s ease-in-out;
        }

        .build-menu.hidden {
            transform: translateY(100%);
        }

        .build-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #9d00ff;
        }

        .build-title {
            font-size: 1.5em;
            color: #9d00ff;
        }

        .close-build-btn {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            border: none;
            color: white;
            padding: 8px 20px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .close-build-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #9d00ff;
        }

        .build-categories {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .category-btn {
            background: rgba(74, 0, 109, 0.5);
            border: 2px solid #9d00ff;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .category-btn.active {
            background: linear-gradient(45deg, #9d00ff, #4a006d);
            box-shadow: 0 0 15px #9d00ff;
        }

        .category-btn:hover {
            background: rgba(157, 0, 255, 0.3);
        }

        .build-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .build-item {
            background: linear-gradient(45deg, #2a0044, #4a006d);
            border: 2px solid #9d00ff;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .build-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(157, 0, 255, 0.5);
            background: linear-gradient(45deg, #4a006d, #9d00ff);
        }

        .build-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .build-item.disabled:hover {
            transform: none;
            box-shadow: none;
            background: linear-gradient(45deg, #2a0044, #4a006d);
        }

        .build-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #00ffff;
        }

        .build-name {
            color: #fff;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .build-cost {
            color: gold;
            font-size: 0.9em;
            font-weight: bold;
        }

        .build-requirements {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 5px;
        }

        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–∞–∑–º–µ—â–µ–Ω–∏—è */
        .drop-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 3px dashed #00ff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 600;
            display: none;
            animation: pulse 1s infinite;
        }

        /* –≠–∫—Ä–∞–Ω –ø–æ—Ä–∞–∂–µ–Ω–∏—è */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 20px;
            border: 5px solid #ff4500;
            text-align: center;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 100px rgba(255, 69, 0, 0.5);
            backdrop-filter: blur(10px);
            min-width: 400px;
        }

        .game-over-title {
            font-size: 3em;
            color: #ff4500;
            text-shadow: 0 0 20px #ff4500;
            margin-bottom: 20px;
        }

        .stats {
            font-size: 1.3em;
            color: #fff;
            margin-bottom: 30px;
        }

        .restart-btn {
            background: linear-gradient(45deg, #ff4500, #ff8800);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
        }

        /* –ó–∞–≥—Ä—É–∑—á–∏–∫ */
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 1100;
        }

        .loader-text {
            font-size: 1.5em;
            color: #9d00ff;
            margin-bottom: 20px;
        }

        .loader-progress-container {
            width: 400px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 2px solid #9d00ff;
        }

        .loader-progress {
            height: 100%;
            background: linear-gradient(90deg, #9d00ff, #00ffff);
            width: 0%;
            transition: width 0.3s;
        }

        .loader-percent {
            font-size: 1.2em;
            color: #00ffff;
            font-weight: bold;
        }

        .controls-hint {
            position: absolute;
            bottom: 120px;
            left: 20px;
            background: rgba(26, 0, 51, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #9d00ff;
            font-size: 0.9em;
            color: #ccc;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .controls-hint.hidden {
            opacity: 0.3;
        }

        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤—ã–±–æ—Ä–∞ */
        .selection-box {
            position: absolute;
            border: 2px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            display: none;
            pointer-events: none;
            z-index: 500;
        }

        /* –ê–Ω–∏–º–∞—Ü–∏–∏ */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes typing {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* HP –±–∞—Ä */
        .hp-bar {
            position: absolute;
            width: 40px;
            height: 4px;
            background: #333;
            border: 1px solid #000;
            border-radius: 2px;
            overflow: hidden;
            pointer-events: none;
            z-index: 610;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            width: 100%;
            transition: width 0.3s;
        }

        /* –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã */
        .attack-range-indicator {
            position: absolute;
            border: 2px solid rgba(255, 69, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 400;
        }

        .patrol-line {
            position: absolute;
            border: 1px dashed #00ff00;
            pointer-events: none;
            display: none;
            z-index: 400;
        }

        /* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 0, 51, 0.9);
            border: 2px solid #ff4500;
            border-radius: 8px;
            padding: 15px 30px;
            color: #fff;
            font-size: 1.1em;
            text-align: center;
            z-index: 1000;
            display: none;
            animation: fadeIn 0.5s;
        }
    </style>
</head>
<body>
    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä -->
    <div id="game-container">
        <!-- –ó–∞—Å—Ç–∞–≤–∫–∞ -->
        <div id="splash-screen">
            <div class="splash-title">KRIMPRODUCTION</div>
            <div class="splash-subtitle">—Å–æ–≤–º–µ—Å—Ç–Ω–æ —Å –û–≥—É–∑–æ–∫‚Ñ¢ –∏ –ê–ª–µ–∫—Å–µ–π¬Æ</div>
            <div class="splash-tm">Warhammer 40 000 Universe</div>
        </div>

        <!-- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∫–∞—Ç-—Å—Ü–µ–Ω–∞ -->
        <div id="cut-scene">
            <div class="cutscene-content">
                <div class="commander-card">
                    <div class="commander-image">
                        ‚öô
                    </div>
                    <div class="commander-info">
                        <div class="commander-name">–ö–û–ú–ê–ù–î–ò–† –õ–ï–ö–°–£–°</div>
                        <div class="commander-title">–ê–¥–µ–ø—Ç—É—Å –ú–µ—Ö–∞–Ω–∏–∫—É—Å, –ö–æ–≥–æ—Ä—Ç VII</div>
                        <div class="commander-title">–ö–æ–º–∞–Ω–¥–∏—Ä –∫–æ—Ä–∞–±–ª—è "–û–º–Ω–∏—Å—Å–∏—è –ü—Ä–∞–π–º"</div>
                    </div>
                </div>
                
                <div id="dialogue-text" class="dialogue-text">
                    –í—ã - –∫–æ–º–∞–Ω–¥–∏—Ä —Å—É–¥–Ω–∞ –ê–¥–µ–ø—Ç—É—Å –ú–µ—Ö–∞–Ω–∏–∫—É—Å, –¥–∏—Ç—è –≤–µ–ª–∏–∫–æ–π –û–º–Ω–∏—Å—Å–∏–∏. –ö –±–æ–ª—å—à–æ–º—É —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à –∫–æ—Ä–∞–±–ª—å –ø–æ—Ç–µ—Ä–ø–µ–ª –∫—Ä—É—à–µ–Ω–∏–µ –Ω–∞ –¥–∞–ª—ë–∫–æ–π –ø–ª–∞–Ω–µ—Ç–µ –î–æ–º–∏–Ω–∏–∫–∞, –Ω–∞—Å–µ–ª—ë–Ω–Ω–æ–π –æ—Ä–∫–∞–º–∏. –ò –≤–∏–¥–∏–º–æ, —ç—Ç–æ –±—É–¥–µ—Ç –≤–∞—à –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–æ–π. –°—Ä–∞–∂–∞–π—Ç–µ—Å—å –¥–æ—Å—Ç–æ–π–Ω–æ, –≤–æ –∏–º—è –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞.<br><br>
                    –í–æ –º—Ä–∞—á–Ω–æ–π —Ç—å–º–µ –¥–∞–ª—ë–∫–æ–≥–æ –±—É–¥—É—â–µ–≥–æ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –≤–æ–π–Ω–∞...
                </div>
                
                <div class="typing-indicator"></div>
                <button class="skip-btn" id="skip-btn">–ü–†–û–ü–£–°–¢–ò–¢–¨</button>
            </div>
        </div>

        <!-- –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
        <div id="game-screen">
            <canvas id="game-canvas"></canvas>
            
            <!-- –ò–≥—Ä–æ–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å -->
            <div id="game-ui">
                <div class="top-bar" id="top-bar">
                    <div class="resources">
                        <div class="resource">
                            <div class="resource-icon credits-icon">‚±†</div>
                            <span id="credits">2000</span>
                        </div>
                        <div class="resource">
                            <div class="resource-icon power-icon">‚ö°</div>
                            <span id="power">300/300</span>
                        </div>
                        <div class="resource">
                            <div class="resource-icon requisition-icon">‚öô</div>
                            <span id="requisition">0/–º–∏–Ω</span>
                        </div>
                        <div class="resource">
                            <div style="color: #00ffff; font-weight: bold;">–í–æ–π—Å–∫–∞:</div>
                            <span id="unit-limit">0/20</span>
                        </div>
                    </div>
                    <div class="wave-info">
                        <div>–í–û–õ–ù–ê: <span id="wave">1</span></div>
                        <div>–î–æ —Å–ª–µ–¥—É—é—â–µ–π: <span id="wave-timer">30</span>—Å</div>
                    </div>
                </div>

                <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º -->
                <div class="ui-controls" id="ui-controls">
                    <div class="ui-toggle-btn" id="toggle-top-bar" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –≤–µ—Ä—Ö–Ω—é—é –ø–∞–Ω–µ–ª—å">üìä</div>
                    <div class="ui-toggle-btn" id="toggle-build-menu" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞">üèóÔ∏è</div>
                    <div class="ui-toggle-btn" id="toggle-info-panel" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—É—é –ø–∞–Ω–µ–ª—å">‚ÑπÔ∏è</div>
                    <div class="ui-toggle-btn" id="toggle-quick-commands" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –±—ã—Å—Ç—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã">‚ö°</div>
                    <div class="ui-toggle-btn" id="toggle-controls-hint" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏">‚ùì</div>
                </div>

                <!-- –ö–Ω–æ–ø–∫–∏ –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ -->
                <div class="quick-commands" id="quick-commands">
                    <div class="quick-command-btn" title="–í—ã–¥–µ–ª–∏—Ç—å –≤—Å–µ—Ö –≤–æ–µ–Ω–Ω—ã—Ö" id="select-all-military">‚öî</div>
                    <div class="quick-command-btn" title="–ó–∞—Ö–≤–∞—Ç–∏—Ç—å –≤—Å–µ —à–∞—Ö—Ç—ã" id="capture-mines">‚õè</div>
                    <div class="quick-command-btn" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –±–∞–∑–µ" id="return-to-base">üè†</div>
                </div>

                <!-- –ö–Ω–æ–ø–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è/—Å–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ -->
                <div class="build-menu-toggle" id="build-menu-toggle">
                    <div class="build-menu-toggle-icon">‚ñº</div>
                </div>

                <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å -->
                <div class="info-panel" id="info-panel">
                    <div class="info-title">–°–¢–†–ê–¢–ï–ì–ò–ß–ï–°–ö–ò–ô –î–ò–°–ü–õ–ï–ô</div>
                    <div class="info-text">‚Ä¢ –í—ã–¥–µ–ª–µ–Ω–∏–µ: –õ–ö–ú + –¥—Ä–∞–≥</div>
                    <div class="info-text">‚Ä¢ –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ: –í—ã–¥–µ–ª–∏—Ç—å + –ü–ö–ú –Ω–∞ –∫–∞—Ä—Ç—É</div>
                    <div class="info-text">‚Ä¢ –í—Ä–∞—â–µ–Ω–∏–µ —Å—Ç–µ–Ω: –ö–æ–ª—ë—Å–∏–∫–æ –ø—Ä–∏ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–µ</div>
                    <div class="info-text">‚Ä¢ –°–∫—Ä—ã—Ç–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞: –∫–Ω–æ–ø–∫–∏ —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É</div>
                    
                    <div class="mine-status">
                        <div class="mine-item">
                            <span class="mine-name">–®–∞—Ö—Ç–∞ –ê–ª—å—Ñ–∞</span>
                            <span class="mine-value" id="mine-1">–°–≤–æ–±–æ–¥–Ω–∞</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">–®–∞—Ö—Ç–∞ –ë–µ—Ç–∞</span>
                            <span class="mine-value" id="mine-2">–°–≤–æ–±–æ–¥–Ω–∞</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">–®–∞—Ö—Ç–∞ –ì–∞–º–º–∞</span>
                            <span class="mine-value" id="mine-3">–°–≤–æ–±–æ–¥–Ω–∞</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">–®–∞—Ö—Ç–∞ –î–µ–ª—å—Ç–∞</span>
                            <span class="mine-value" id="mine-4">–°–≤–æ–±–æ–¥–Ω–∞</span>
                        </div>
                        <div class="mine-item">
                            <span class="mine-name">–®–∞—Ö—Ç–∞ –≠–ø—Å–∏–ª–æ–Ω</span>
                            <span class="mine-value" id="mine-5">–°–≤–æ–±–æ–¥–Ω–∞</span>
                        </div>
                    </div>
                    
                    <div class="unit-status">
                        <div class="unit-item">
                            <span class="unit-type">–ö–∞–∑–∞—Ä–º—ã</span>
                            <span class="unit-count" id="barracks-count">0</span>
                        </div>
                        <div class="unit-item">
                            <span class="unit-type">–°—Ç–µ–Ω—ã</span>
                            <span class="unit-count" id="walls-count">0</span>
                        </div>
                    </div>
                    
                    <div class="info-text" style="color: #ff4500; margin-top: 10px;">
                        –ë–∞–∑–∞: <span id="base-hp">1000</span> HP
                    </div>
                </div>

                <!-- –ü–∞–Ω–µ–ª—å –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤ -->
                <div class="selection-panel" id="selection-panel"></div>

                <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–∞–∑–º–µ—â–µ–Ω–∏—è -->
                <div class="drop-indicator" id="drop-indicator"></div>

                <!-- –ü–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é -->
                <div class="controls-hint" id="controls-hint">
                    –°—Ç—Ä–µ–ª–∫–∏ - –¥–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã<br>
                    –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ + –¥–≤–∏–∂–µ–Ω–∏–µ - –≤—Ä–∞—â–µ–Ω–∏–µ<br>
                    –ö–æ–ª–µ—Å–∏–∫–æ - –∑—É–º (–∫—Ä–æ–º–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ —Å—Ç–µ–Ω)<br>
                    –õ–ö–ú + –¥—Ä–∞–≥ - –≤—ã–¥–µ–ª–µ–Ω–∏–µ —é–Ω–∏—Ç–æ–≤<br>
                    –ü–ö–ú - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤<br>
                    Ctrl + 1-9 - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä—É–ø–ø—É<br>
                    1-9 - –≤—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É
                </div>

                <!-- –ë–æ–∫—Å –≤—ã–¥–µ–ª–µ–Ω–∏—è -->
                <div class="selection-box" id="selection-box"></div>

                <!-- –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã -->
                <div class="attack-range-indicator" id="attack-range-indicator"></div>
                <div class="patrol-line" id="patrol-line"></div>

                <!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è -->
                <div class="notification" id="notification"></div>
            </div>
        </div>

        <!-- –ú–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∏–¥–∏–º–æ) -->
        <div class="build-menu" id="build-menu">
            <div class="build-menu-header">
                <div class="build-title">–ú–ï–ù–Æ –°–¢–†–û–ò–¢–ï–õ–¨–°–¢–í–ê</div>
                <button class="close-build-btn" id="close-build-btn">–°–ö–†–´–¢–¨</button>
            </div>
            
            <div class="build-categories" id="build-categories">
                <button class="category-btn active" data-category="units">–í–û–ô–°–ö–ê</button>
                <button class="category-btn" data-category="buildings">–ó–î–ê–ù–ò–Ø</button>
                <button class="category-btn" data-category="defenses">–û–ë–û–†–û–ù–ê</button>
                <button class="category-btn" data-category="upgrades">–£–õ–£–ß–®–ï–ù–ò–Ø</button>
            </div>
            
            <div class="build-items" id="build-items">
                <!-- –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω—è—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
        </div>

        <!-- –≠–∫—Ä–∞–Ω –ø–æ—Ä–∞–∂–µ–Ω–∏—è -->
        <div class="game-over" id="game-over">
            <div class="game-over-title">–ü–û–†–ê–ñ–ï–ù–ò–ï</div>
            <div class="stats">
                –í—ã –ø—Ä–æ–¥–µ—Ä–∂–∞–ª–∏—Å—å <span id="survived-waves">0</span> –≤–æ–ª–Ω<br>
                –£–Ω–∏—á—Ç–æ–∂–µ–Ω–æ –≤—Ä–∞–≥–æ–≤: <span id="enemies-killed">0</span><br>
                –î–æ–±—ã—Ç–æ —Ä–µ—Å—É—Ä—Å–æ–≤: <span id="resources-earned">0</span> ‚±†
            </div>
            <button class="restart-btn" id="restart-btn">–ù–ê–ß–ê–¢–¨ –ó–ê–ù–û–í–û</button>
        </div>

        <!-- –ó–∞–≥—Ä—É–∑—á–∏–∫ -->
        <div class="loader" id="loader">
            <div class="loader-text" id="loader-text">–ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ò–°–¢–ï–ú</div>
            <div class="loader-progress-container">
                <div class="loader-progress" id="loader-progress"></div>
            </div>
            <div class="loader-percent" id="loader-percent">0%</div>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π –∫–æ–¥ -->
    <script>
        // ==================== –ú–ï–ù–ï–î–ñ–ï–† –ó–ê–ì–†–£–ó–ö–ò ====================
        class LoadManager {
            constructor() {
                this.progress = 0;
                this.totalAssets = 10;
                this.loadedAssets = 0;
            }

            show() {
                document.getElementById('loader').style.display = 'block';
            }

            hide() {
                document.getElementById('loader').style.display = 'none';
            }

            updateProgress() {
                this.loadedAssets++;
                this.progress = Math.min(100, Math.round((this.loadedAssets / this.totalAssets) * 100));
                document.getElementById('loader-progress').style.width = this.progress + '%';
                document.getElementById('loader-percent').textContent = this.progress + '%';
            }

            async load(description) {
                document.getElementById('loader-text').textContent = description;
                this.updateProgress();
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 200));
            }
        }

        // ==================== –ó–ê–°–¢–ê–í–ö–ê ====================
        class SplashScreen {
            static show() {
                return new Promise(resolve => {
                    const splash = document.getElementById('splash-screen');
                    splash.style.display = 'flex';
                    
                    setTimeout(() => {
                        splash.style.opacity = '0';
                        setTimeout(() => {
                            splash.style.display = 'none';
                            splash.style.opacity = '1';
                            resolve();
                        }, 1000);
                    }, 2000);
                });
            }
        }

        // ==================== –ö–ê–¢-–°–¶–ï–ù–ê ====================
        class Cutscene {
            constructor() {
                this.dialogueText = document.getElementById('dialogue-text');
                this.fullText = this.dialogueText.innerHTML;
                this.dialogueText.innerHTML = '';
                this.currentIndex = 0;
                this.isTyping = false;
                this.skipped = false;
                this.typingSpeed = 30;
                this.resolvePromise = null;
            }

            show() {
                return new Promise(resolve => {
                    this.resolvePromise = resolve;
                    document.getElementById('cut-scene').style.display = 'flex';
                    this.startTyping();
                    
                    document.getElementById('skip-btn').addEventListener('click', () => this.skip());
                });
            }

            startTyping() {
                this.isTyping = true;
                this.typeWriter();
            }

            typeWriter() {
                if (this.skipped || this.currentIndex >= this.fullText.length) {
                    this.isTyping = false;
                    setTimeout(() => {
                        this.hide();
                        if (this.resolvePromise) this.resolvePromise();
                    }, 1500);
                    return;
                }

                this.dialogueText.innerHTML = this.fullText.substring(0, this.currentIndex + 1);
                this.currentIndex++;

                setTimeout(() => this.typeWriter(), this.typingSpeed);
            }

            skip() {
                if (this.isTyping) {
                    this.skipped = true;
                    this.dialogueText.innerHTML = this.fullText;
                } else {
                    this.hide();
                    if (this.resolvePromise) this.resolvePromise();
                }
            }

            hide() {
                const cutScene = document.getElementById('cut-scene');
                cutScene.style.opacity = '0';
                setTimeout(() => {
                    cutScene.style.display = 'none';
                    cutScene.style.opacity = '1';
                }, 500);
            }
        }

        // ==================== –û–°–ù–û–í–ù–ê–Ø –ò–ì–†–ê ====================
        class Game {
            constructor() {
                this.loader = new LoadManager();
                this.cutscene = null;
                this.gameState = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.keys = {};
                this.mouseButtons = {};
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraPosition = new THREE.Vector3(0, 150, 200);
                this.cameraDistance = 200;
                this.cameraRotation = { x: -Math.PI / 4, y: 0 };
                this.isRotating = false;
                this.lastMousePosition = { x: 0, y: 0 };
                this.selectedUnits = [];
                this.dragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.rotationMode = false;
                
                this.gameLoopId = null;
                this.waveInterval = null;
                this.economyInterval = null;
                this.waveTimerInterval = null;
                this.buildQueue = [];
                this.placingBuilding = null;
                this.placingObject = null;
                this.currentBuildCategory = 'units';
                
                this.hpBars = new Map();
                this.selectionBox = document.getElementById('selection-box');
                this.attackRangeIndicator = document.getElementById('attack-range-indicator');
                this.patrolLine = document.getElementById('patrol-line');
                this.notification = document.getElementById('notification');
                
                this.unitGroups = new Array(9).fill(null).map(() => []);
                this.currentGroupKey = null;
                
                this.mineCaptureRange = 20;
                this.patrolPoints = [];
                
                // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
                this.uiVisibility = {
                    topBar: true,
                    buildMenu: true,
                    infoPanel: true,
                    quickCommands: true,
                    controlsHint: true
                };
            }

            static async start() {
                const game = new Game();
                await game.init();
                window.Game = game;
            }

            static restart() {
                if (window.Game) {
                    window.Game.cleanup();
                }
                location.reload();
            }

            cleanup() {
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                if (this.waveInterval) clearInterval(this.waveInterval);
                if (this.economyInterval) clearInterval(this.economyInterval);
                if (this.waveTimerInterval) clearInterval(this.waveTimerInterval);
                
                const skipBtn = document.getElementById('skip-btn');
                const restartBtn = document.getElementById('restart-btn');
                if (skipBtn) {
                    skipBtn.replaceWith(skipBtn.cloneNode(true));
                }
                if (restartBtn) {
                    restartBtn.replaceWith(restartBtn.cloneNode(true));
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
            }

            async init() {
                try {
                    await SplashScreen.show();
                    
                    this.loader.show();
                    
                    if (typeof THREE === 'undefined') {
                        throw new Error('Three.js –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω');
                    }
                    
                    await this.loader.load("–ó–∞–≥—Ä—É–∑–∫–∞ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –¥–≤–∏–∂–∫–∞...");
                    await this.initThreeJS();
                    
                    await this.loader.load("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–≥—Ä–æ–≤—ã—Ö —Å–∏—Å—Ç–µ–º...");
                    await this.initGameSystems();
                    
                    await this.loader.load("–°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –º–∏—Ä–∞...");
                    await this.createGameWorld();
                    
                    await this.loader.load("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...");
                    await this.initUI();
                    
                    await this.loader.load("–§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞...");
                    
                    this.cutscene = new Cutscene();
                    
                    this.loader.hide();
                    await this.cutscene.show();
                    await this.startGameplay();
                    
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', error);
                    this.loader.hide();
                    this.showErrorMessage('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–≥—Ä—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
                }
            }

            showErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">–û–®–ò–ë–ö–ê</h2>
                    <p style="margin-bottom: 20px;">${message}</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">–û–ë–ù–û–í–ò–¢–¨ –°–¢–†–ê–ù–ò–¶–£</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
            }

            async initThreeJS() {
                return new Promise((resolve) => {
                    try {
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x000000);
                        
                        this.camera = new THREE.PerspectiveCamera(
                            60,
                            window.innerWidth / window.innerHeight,
                            1,
                            2000
                        );
                        this.updateCameraPosition();
                        
                        const canvas = document.getElementById('game-canvas');
                        this.renderer = new THREE.WebGLRenderer({
                            canvas: canvas,
                            antialias: true
                        });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        this.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                        directionalLight.position.set(100, 200, 100);
                        directionalLight.castShadow = true;
                        this.scene.add(directionalLight);
                        
                        window.addEventListener('resize', () => this.onWindowResize());
                        
                        resolve();
                    } catch (error) {
                        console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Three.js:', error);
                        throw error;
                    }
                });
            }

            updateCameraPosition() {
                const phi = this.cameraRotation.x;
                const theta = this.cameraRotation.y;
                
                const x = this.cameraTarget.x + this.cameraDistance * Math.sin(phi) * Math.sin(theta);
                const y = this.cameraTarget.y + this.cameraDistance * Math.cos(phi);
                const z = this.cameraTarget.z + this.cameraDistance * Math.sin(phi) * Math.cos(theta);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(this.cameraTarget);
            }

            async initGameSystems() {
                return new Promise((resolve) => {
                    this.gameState = {
                        credits: 2000,
                        power: 300,
                        powerMax: 300,
                        requisition: 0,
                        currentWave: 1,
                        waveTimer: 30,
                        baseHP: 1000,
                        baseMaxHP: 1000,
                        enemiesKilled: 0,
                        resourcesEarned: 0,
                        controlledMines: 0,
                        totalMines: 5,
                        mineIncome: 50,
                        unitLimit: 20,
                        currentUnits: 0,
                        barracksCount: 0,
                        wallsCount: 0,
                        gameTime: 0,
                        gameActive: false,
                        units: [],
                        enemies: [],
                        buildings: [],
                        walls: [],
                        mines: [],
                        selectedUnits: [],
                        upgrades: {
                            skitariiWeapons: false,
                            turretRange: false,
                            dreadnoughtArmor: false
                        }
                    };
                    
                    this.unitsData = {
                        skitarii: { 
                            cost: 250, 
                            hp: 100,
                            maxHP: 100,
                            damage: 20, 
                            range: 40, 
                            attackSpeed: 1.5,
                            speed: 2.5,
                            sight: 60,
                            color: 0x9d00ff,
                            movable: true,
                            buildTime: 5000,
                            icon: '‚öî'
                        },
                        turret: { 
                            cost: 500, 
                            hp: 300,
                            maxHP: 300,
                            damage: 50, 
                            range: 80, 
                            attackSpeed: 0.8,
                            speed: 0,
                            sight: 100,
                            color: 0xffd700,
                            movable: false,
                            buildTime: 10000,
                            icon: '‚ò¢'
                        },
                        dreadnought: { 
                            cost: 1000, 
                            hp: 800,
                            maxHP: 800,
                            damage: 80, 
                            range: 25, 
                            attackSpeed: 1.0,
                            speed: 1.2,
                            sight: 50,
                            color: 0xff4500,
                            movable: true,
                            buildTime: 15000,
                            icon: '‚öô'
                        }
                    };
                    
                    this.buildingsData = {
                        barracks: {
                            cost: 1000,
                            hp: 500,
                            maxHP: 500,
                            unitLimitIncrease: 10,
                            color: 0x4a006d,
                            size: { width: 10, depth: 8 },
                            buildTime: 20000,
                            icon: 'üèõ'
                        },
                        wall: {
                            cost: 200,
                            hp: 300,
                            maxHP: 300,
                            color: 0x666666,
                            size: { width: 5, depth: 2 },
                            buildTime: 5000,
                            icon: 'üß±'
                        },
                        powerPlant: {
                            cost: 800,
                            hp: 400,
                            maxHP: 400,
                            powerIncrease: 100,
                            color: 0x00ffff,
                            size: { width: 8, depth: 8 },
                            buildTime: 15000,
                            icon: '‚ö°'
                        }
                    };
                    
                    this.enemyData = {
                        basic: {
                            hp: 100,
                            maxHP: 100,
                            damage: 15,
                            speed: 1.2,
                            sight: 50,
                            attackRange: 2,
                            aggressionRange: 80,
                            bounty: 50,
                            color: 0x00ff00
                        },
                        heavy: {
                            hp: 300,
                            maxHP: 300,
                            damage: 35,
                            speed: 0.8,
                            sight: 40,
                            attackRange: 20,
                            aggressionRange: 60,
                            bounty: 150,
                            color: 0xff8800
                        },
                        boss: {
                            hp: 1000,
                            maxHP: 1000,
                            damage: 60,
                            speed: 0.5,
                            sight: 100,
                            attackRange: 30,
                            aggressionRange: 120,
                            bounty: 500,
                            color: 0xff0000
                        }
                    };
                    
                    this.upgradesData = {
                        skitariiWeapons: {
                            cost: 1000,
                            name: '–£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ',
                            description: '+30% —É—Ä–æ–Ω–∞ –°–∫–∏—Ç–∞—Ä–∏—è–º',
                            icon: 'üî´'
                        },
                        turretRange: {
                            cost: 1500,
                            name: '–£–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–µ–Ω—Å–æ—Ä—ã',
                            description: '+40% –¥–∞–ª—å–Ω–æ—Å—Ç–∏ —Ç—É—Ä–µ–ª–µ–π',
                            icon: 'üì°'
                        },
                        dreadnoughtArmor: {
                            cost: 2000,
                            name: '–£—Å–∏–ª–µ–Ω–Ω–∞—è –±—Ä–æ–Ω—è',
                            description: '+50% HP –î—Ä–µ–¥–Ω–æ—É—Ç–∞–º',
                            icon: 'üõ°Ô∏è'
                        }
                    };
                    
                    resolve();
                });
            }

            async createGameWorld() {
                return new Promise((resolve) => {
                    const groundGeometry = new THREE.CircleGeometry(500, 128);
                    const groundMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a2e,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    this.scene.add(ground);
                    
                    const gridHelper = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
                    gridHelper.position.y = 0.1;
                    this.scene.add(gridHelper);
                    
                    this.createBase();
                    this.createMines();
                    this.createDecorations();
                    
                    resolve();
                });
            }

            createBase() {
                const baseGroup = new THREE.Group();
                
                const towerGeometry = new THREE.CylinderGeometry(20, 25, 40, 16);
                const towerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.y = 20;
                tower.castShadow = true;
                baseGroup.add(tower);
                
                const coreGeometry = new THREE.SphereGeometry(8, 16, 16);
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                this.core = new THREE.Mesh(coreGeometry, coreMaterial);
                this.core.position.y = 20;
                baseGroup.add(this.core);
                
                const platformGeometry = new THREE.CylinderGeometry(30, 35, 5, 16);
                const platformMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.6,
                    roughness: 0.4
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = 2.5;
                baseGroup.add(platform);
                
                this.scene.add(baseGroup);
                this.baseObject = baseGroup;
            }

            createMines() {
                const minePositions = [
                    { x: 200, z: 0, name: "–ê–ª—å—Ñ–∞" },
                    { x: -200, z: 0, name: "–ë–µ—Ç–∞" },
                    { x: 0, z: 200, name: "–ì–∞–º–º–∞" },
                    { x: 0, z: -200, name: "–î–µ–ª—å—Ç–∞" },
                    { x: 150, z: 150, name: "–≠–ø—Å–∏–ª–æ–Ω" }
                ];

                minePositions.forEach((pos, index) => {
                    const mineGroup = new THREE.Group();
                    
                    const platformGeometry = new THREE.CylinderGeometry(12, 15, 4, 8);
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.y = 2;
                    platform.castShadow = true;
                    mineGroup.add(platform);
                    
                    const drillGeometry = new THREE.CylinderGeometry(4, 3, 20, 8);
                    const drillMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff4500,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const drill = new THREE.Mesh(drillGeometry, drillMaterial);
                    drill.position.y = 12;
                    mineGroup.add(drill);
                    
                    mineGroup.position.set(pos.x, 0, pos.z);
                    this.scene.add(mineGroup);
                    
                    const mine = {
                        id: index,
                        group: mineGroup,
                        drill: drill,
                        x: pos.x,
                        z: pos.z,
                        name: pos.name,
                        controlled: false,
                        income: 50,
                        captureProgress: 0
                    };
                    
                    this.gameState.mines.push(mine);
                });
            }

            createDecorations() {
                for (let i = 0; i < 50; i++) {
                    const size = 3 + Math.random() * 12;
                    const rockGeometry = new THREE.DodecahedronGeometry(size, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        roughness: 0.8
                    });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 350;
                    rock.position.x = Math.cos(angle) * distance;
                    rock.position.z = Math.sin(angle) * distance;
                    rock.position.y = size / 2;
                    
                    rock.castShadow = true;
                    this.scene.add(rock);
                }
            }

            async initUI() {
                return new Promise((resolve) => {
                    document.getElementById('restart-btn').addEventListener('click', () => Game.restart());
                    
                    document.getElementById('select-all-military').addEventListener('click', () => this.selectAllMilitary());
                    document.getElementById('capture-mines').addEventListener('click', () => this.orderCaptureMines());
                    document.getElementById('return-to-base').addEventListener('click', () => this.orderReturnToBase());
                    
                    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–Ω–æ–ø–æ–∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
                    this.setupUIControls();
                    
                    this.setupBuildMenu();
                    this.setupControls();
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
                    this.applyUIVisibility();
                    
                    resolve();
                });
            }

            setupUIControls() {
                // –ö–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
                const uiControls = {
                    'toggle-top-bar': { element: 'top-bar', key: 'topBar' },
                    'toggle-build-menu': { element: 'build-menu', key: 'buildMenu' },
                    'toggle-info-panel': { element: 'info-panel', key: 'infoPanel' },
                    'toggle-quick-commands': { element: 'quick-commands', key: 'quickCommands' },
                    'toggle-controls-hint': { element: 'controls-hint', key: 'controlsHint' }
                };
                
                for (const [buttonId, config] of Object.entries(uiControls)) {
                    const button = document.getElementById(buttonId);
                    button.addEventListener('click', () => {
                        this.uiVisibility[config.key] = !this.uiVisibility[config.key];
                        this.updateUIButtonState(buttonId, config.key);
                        this.toggleUIVisibility(config.element, config.key);
                    });
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–æ–∫
                    this.updateUIButtonState(buttonId, config.key);
                }
            }

            updateUIButtonState(buttonId, visibilityKey) {
                const button = document.getElementById(buttonId);
                const isVisible = this.uiVisibility[visibilityKey];
                
                button.classList.remove('active', 'inactive');
                button.classList.add(isVisible ? 'active' : 'inactive');
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏
                button.title = isVisible ? 
                    `–°–∫—Ä—ã—Ç—å ${this.getUITitle(visibilityKey)}` : 
                    `–ü–æ–∫–∞–∑–∞—Ç—å ${this.getUITitle(visibilityKey)}`;
            }

            getUITitle(key) {
                const titles = {
                    'topBar': '–≤–µ—Ä—Ö–Ω—é—é –ø–∞–Ω–µ–ª—å',
                    'buildMenu': '–º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞',
                    'infoPanel': '–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—É—é –ø–∞–Ω–µ–ª—å',
                    'quickCommands': '–±—ã—Å—Ç—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã',
                    'controlsHint': '–ø–æ–¥—Å–∫–∞–∑–∫–∏'
                };
                return titles[key] || '';
            }

            toggleUIVisibility(elementId, visibilityKey) {
                const element = document.getElementById(elementId);
                const isVisible = this.uiVisibility[visibilityKey];
                
                if (elementId === 'build-menu') {
                    // –î–ª—è –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª–∞—Å—Å hidden
                    if (isVisible) {
                        element.classList.remove('hidden');
                    } else {
                        element.classList.add('hidden');
                    }
                } else {
                    // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º opacity –∏–ª–∏ display
                    if (element.classList.contains('hidden')) {
                        element.classList.toggle('hidden', !isVisible);
                    } else {
                        element.style.opacity = isVisible ? '1' : '0.3';
                        element.style.pointerEvents = isVisible ? 'all' : 'none';
                    }
                }
            }

            applyUIVisibility() {
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –¥–ª—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                for (const [key, isVisible] of Object.entries(this.uiVisibility)) {
                    const config = {
                        'topBar': { element: 'top-bar', useClass: false },
                        'buildMenu': { element: 'build-menu', useClass: true },
                        'infoPanel': { element: 'info-panel', useClass: false },
                        'quickCommands': { element: 'quick-commands', useClass: false },
                        'controlsHint': { element: 'controls-hint', useClass: false }
                    };
                    
                    if (config[key]) {
                        const element = document.getElementById(config[key].element);
                        if (config[key].useClass) {
                            element.classList.toggle('hidden', !isVisible);
                        } else {
                            element.style.opacity = isVisible ? '1' : '0.3';
                            element.style.pointerEvents = isVisible ? 'all' : 'none';
                        }
                    }
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–æ–∫
                this.updateAllUIButtons();
            }

            updateAllUIButtons() {
                const uiControls = {
                    'toggle-top-bar': 'topBar',
                    'toggle-build-menu': 'buildMenu',
                    'toggle-info-panel': 'infoPanel',
                    'toggle-quick-commands': 'quickCommands',
                    'toggle-controls-hint': 'controlsHint'
                };
                
                for (const [buttonId, key] of Object.entries(uiControls)) {
                    this.updateUIButtonState(buttonId, key);
                }
            }

            setupBuildMenu() {
                const buildMenuToggle = document.getElementById('build-menu-toggle');
                const closeBtn = document.getElementById('close-build-btn');
                const buildMenu = document.getElementById('build-menu');
                
                // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –≤–∏–¥–∏–º–æ
                buildMenu.classList.remove('hidden');
                this.uiVisibility.buildMenu = true;
                
                buildMenuToggle.addEventListener('click', () => {
                    // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                    this.uiVisibility.buildMenu = !this.uiVisibility.buildMenu;
                    this.toggleUIVisibility('build-menu', 'buildMenu');
                    this.updateUIButtonState('toggle-build-menu', 'buildMenu');
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –Ω–∞ –∫–Ω–æ–ø–∫–µ
                    buildMenuToggle.classList.toggle('active', this.uiVisibility.buildMenu);
                });
                
                closeBtn.addEventListener('click', () => {
                    // –°–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                    this.uiVisibility.buildMenu = false;
                    this.toggleUIVisibility('build-menu', 'buildMenu');
                    this.updateUIButtonState('toggle-build-menu', 'buildMenu');
                    buildMenuToggle.classList.remove('active');
                });
                
                const categories = document.querySelectorAll('.category-btn');
                categories.forEach(btn => {
                    btn.addEventListener('click', () => {
                        categories.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentBuildCategory = btn.dataset.category;
                        this.updateBuildItems();
                    });
                });
                
                this.updateBuildItems();
            }

            selectAllMilitary() {
                this.clearSelection();
                this.gameState.units.forEach(unit => {
                    if (unit.userData.movable) {
                        this.selectUnit(unit);
                    }
                });
            }

            orderCaptureMines() {
                if (this.selectedUnits.length === 0) return;
                
                const minesToCapture = this.gameState.mines.filter(mine => !mine.controlled);
                if (minesToCapture.length === 0) {
                    this.showNotification('–í—Å–µ —à–∞—Ö—Ç—ã —É–∂–µ –∑–∞—Ö–≤–∞—á–µ–Ω—ã!');
                    return;
                }
                
                minesToCapture.forEach((mine, index) => {
                    const unit = this.selectedUnits[index % this.selectedUnits.length];
                    if (unit && unit.userData.movable) {
                        unit.userData.destination = new THREE.Vector3(mine.x, 0, mine.z);
                        unit.userData.isMoving = true;
                        unit.userData.task = 'capture';
                    }
                });
                
                this.showNotification('–û—Ç–ø—Ä–∞–≤–ª—è—é –≤–æ–π—Å–∫–∞ –Ω–∞ –∑–∞—Ö–≤–∞—Ç —à–∞—Ö—Ç!');
            }

            orderReturnToBase() {
                this.selectedUnits.forEach(unit => {
                    if (unit.userData.movable) {
                        unit.userData.destination = new THREE.Vector3(0, 0, 0);
                        unit.userData.isMoving = true;
                        unit.userData.task = 'return';
                    }
                });
            }

            setupControls() {
                window.addEventListener('keydown', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    const key = e.key.toLowerCase();
                    this.keys[key] = true;
                    
                    if (key === 'escape') {
                        if (this.placingBuilding) {
                            this.cancelPlacing();
                        } else {
                            this.clearSelection();
                        }
                    }
                    
                    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≥—Ä—É–ø–ø (Ctrl + 1-9)
                    if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
                        const groupIndex = parseInt(e.key) - 1;
                        this.saveUnitGroup(groupIndex);
                    }
                    
                    // –í—ã–±–æ—Ä –≥—Ä—É–ø–ø (1-9)
                    if (!e.ctrlKey && e.key >= '1' && e.key <= '9') {
                        const groupIndex = parseInt(e.key) - 1;
                        this.selectUnitGroup(groupIndex);
                    }
                    
                    // –ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ (P)
                    if (key === 'p') {
                        this.startPatrolMode();
                    }
                    
                    // –ë—ã—Å—Ç—Ä–æ–µ —Å–∫—Ä—ã—Ç–∏–µ/–ø–æ–∫–∞–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (H)
                    if (key === 'h') {
                        this.toggleAllUI();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (!this.gameState?.gameActive) return;
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                const canvas = document.getElementById('game-canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (e.button === 0) {
                        if (this.placingBuilding) {
                            this.placeBuilding(e);
                        } else {
                            this.dragging = true;
                            this.dragStart.x = e.clientX;
                            this.dragStart.y = e.clientY;
                            this.selectionBox.style.display = 'none';
                            
                            const rect = e.target.getBoundingClientRect();
                            this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                            this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(this.mouse, this.camera);
                            const intersects = this.raycaster.intersectObjects([
                                ...this.gameState.units,
                                ...this.gameState.buildings
                            ]);
                            
                            if (intersects.length > 0 && !this.keys.shift) {
                                this.clearSelection();
                                this.selectObject(intersects[0].object);
                                this.dragging = false;
                            }
                        }
                    }
                    
                    if (e.button === 1) {
                        e.preventDefault();
                        this.isRotating = true;
                        this.lastMousePosition.x = e.clientX;
                        this.lastMousePosition.y = e.clientY;
                        canvas.style.cursor = 'grabbing';
                    }
                    
                    if (e.button === 2) {
                        e.preventDefault();
                        if (this.selectedUnits.length > 0) {
                            this.moveSelectedUnits(e);
                        }
                    }
                    
                    this.mouseButtons[e.button] = true;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (this.dragging) {
                        const currentX = e.clientX;
                        const currentY = e.clientY;
                        
                        this.selectionBox.style.left = Math.min(this.dragStart.x, currentX) + 'px';
                        this.selectionBox.style.top = Math.min(this.dragStart.y, currentY) + 'px';
                        this.selectionBox.style.width = Math.abs(currentX - this.dragStart.x) + 'px';
                        this.selectionBox.style.height = Math.abs(currentY - this.dragStart.y) + 'px';
                        this.selectionBox.style.display = 'block';
                    }
                    
                    if (this.isRotating) {
                        const deltaX = e.clientX - this.lastMousePosition.x;
                        const deltaY = e.clientY - this.lastMousePosition.y;
                        
                        this.cameraRotation.y -= deltaX * 0.005;
                        this.cameraRotation.x -= deltaY * 0.005;
                        
                        this.cameraRotation.x = Math.max(-Math.PI / 2, Math.min(-0.1, this.cameraRotation.x));
                        
                        this.updateCameraPosition();
                        this.lastMousePosition.x = e.clientX;
                        this.lastMousePosition.y = e.clientY;
                    }
                    
                    if (this.placingObject) {
                        const rect = e.target.getBoundingClientRect();
                        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        
                        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                        const intersectionPoint = new THREE.Vector3();
                        
                        if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                            this.placingObject.position.x = intersectionPoint.x;
                            this.placingObject.position.z = intersectionPoint.z;
                        }
                    }
                    
                    this.updateAttackRangeIndicator(e);
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (e.button === 0 && this.dragging) {
                        this.dragging = false;
                        this.selectUnitsInBox(e);
                        this.selectionBox.style.display = 'none';
                    }
                    
                    if (e.button === 1) {
                        this.isRotating = false;
                        canvas.style.cursor = 'default';
                    }
                    
                    if (e.button === 2) {
                        if (this.keys.shift && this.selectedUnits.length > 0) {
                            this.addPatrolPoint(e);
                        }
                    }
                    
                    this.mouseButtons[e.button] = false;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    if (!this.gameState?.gameActive) return;
                    e.preventDefault();
                    
                    if (this.placingBuilding === 'wall' && this.placingObject) {
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        this.placingObject.rotation.y += delta;
                    } else {
                        const zoomSpeed = 15;
                        const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                        
                        this.cameraDistance = Math.max(50, Math.min(500, this.cameraDistance + delta));
                        this.updateCameraPosition();
                    }
                });
                
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            toggleAllUI() {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤—Å–µ –ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —Å–∫—Ä—ã—Ç—ã
                const allHidden = Object.values(this.uiVisibility).every(visible => !visible);
                
                // –ï—Å–ª–∏ –≤—Å–µ —Å–∫—Ä—ã—Ç—ã - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ, –∏–Ω–∞—á–µ —Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ
                const newState = allHidden;
                
                for (const key in this.uiVisibility) {
                    this.uiVisibility[key] = newState;
                }
                
                this.applyUIVisibility();
                this.showNotification(newState ? '–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–æ–∫–∞–∑–∞–Ω' : '–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–∫—Ä—ã—Ç');
            }

            updateAttackRangeIndicator(e) {
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.gameState.units);
                if (intersects.length > 0 && intersects[0].object.userData.range) {
                    const unit = intersects[0].object;
                    const screenPos = unit.position.clone().project(this.camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    
                    const range = unit.userData.range * 2;
                    this.attackRangeIndicator.style.left = (x - range) + 'px';
                    this.attackRangeIndicator.style.top = (y - range) + 'px';
                    this.attackRangeIndicator.style.width = range * 2 + 'px';
                    this.attackRangeIndicator.style.height = range * 2 + 'px';
                    this.attackRangeIndicator.style.display = 'block';
                } else {
                    this.attackRangeIndicator.style.display = 'none';
                }
            }

            updateBuildItems() {
                const buildItems = document.getElementById('build-items');
                buildItems.innerHTML = '';
                
                let items = [];
                
                switch(this.currentBuildCategory) {
                    case 'units':
                        items = [
                            { type: 'skitarii', name: '–°–∫–∏—Ç–∞—Ä–∏–π', cost: 250, icon: '‚öî', requirements: '' },
                            { type: 'turret', name: '–¢—É—Ä–µ–ª—å', cost: 500, icon: '‚ò¢', requirements: '' },
                            { type: 'dreadnought', name: '–î—Ä–µ–¥–Ω–æ—É—Ç', cost: 1000, icon: '‚öô', requirements: '' }
                        ];
                        break;
                    case 'buildings':
                        items = [
                            { type: 'barracks', name: '–ö–∞–∑–∞—Ä–º—ã', cost: 1000, icon: 'üèõ', requirements: '–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –ª–∏–º–∏—Ç –≤–æ–π—Å–∫ –Ω–∞ 10' },
                            { type: 'powerPlant', name: '–≠–ª–µ–∫—Ç—Ä–æ—Å—Ç–∞–Ω—Ü–∏—è', cost: 800, icon: '‚ö°', requirements: '+100 –∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–∏' }
                        ];
                        break;
                    case 'defenses':
                        items = [
                            { type: 'wall', name: '–°—Ç–µ–Ω–∞', cost: 200, icon: 'üß±', requirements: '–ë–ª–æ–∫–∏—Ä—É–µ—Ç –ø—Ä–æ—Ö–æ–¥ –≤—Ä–∞–≥–∞–º' }
                        ];
                        break;
                    case 'upgrades':
                        items = [
                            { 
                                type: 'skitariiWeapons', 
                                name: '–£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ', 
                                cost: 1000, 
                                icon: 'üî´', 
                                requirements: '+30% —É—Ä–æ–Ω–∞ –°–∫–∏—Ç–∞—Ä–∏—è–º',
                                purchased: this.gameState.upgrades.skitariiWeapons
                            },
                            { 
                                type: 'turretRange', 
                                name: '–£–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–µ–Ω—Å–æ—Ä—ã', 
                                cost: 1500, 
                                icon: 'üì°', 
                                requirements: '+40% –¥–∞–ª—å–Ω–æ—Å—Ç–∏ —Ç—É—Ä–µ–ª–µ–π',
                                purchased: this.gameState.upgrades.turretRange
                            },
                            { 
                                type: 'dreadnoughtArmor', 
                                name: '–£—Å–∏–ª–µ–Ω–Ω–∞—è –±—Ä–æ–Ω—è', 
                                cost: 2000, 
                                icon: 'üõ°Ô∏è', 
                                requirements: '+50% HP –î—Ä–µ–¥–Ω–æ—É—Ç–∞–º',
                                purchased: this.gameState.upgrades.dreadnoughtArmor
                            }
                        ];
                        break;
                }
                
                items.forEach(item => {
                    const canAfford = this.gameState.credits >= item.cost;
                    const canBuild = item.type === 'skitarii' || item.type === 'dreadnought' ? 
                        this.gameState.currentUnits < this.gameState.unitLimit : true;
                    
                    const isPurchased = item.purchased === true;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `build-item ${!canAfford || !canBuild || isPurchased ? 'disabled' : ''}`;
                    itemDiv.innerHTML = `
                        <div class="build-icon">${item.icon}</div>
                        <div class="build-name">${item.name}</div>
                        <div class="build-cost">${item.cost} ‚±†</div>
                        ${item.requirements ? `<div class="build-requirements">${item.requirements}</div>` : ''}
                        ${isPurchased ? '<div style="color:#00ff00;margin-top:5px;">–ö—É–ø–ª–µ–Ω–æ</div>' : ''}
                    `;
                    
                    if (canAfford && canBuild && !isPurchased) {
                        itemDiv.addEventListener('click', () => {
                            if (item.type === 'skitariiWeapons' || item.type === 'turretRange' || item.type === 'dreadnoughtArmor') {
                                this.purchaseUpgrade(item.type);
                            } else {
                                this.startPlacingBuilding(item.type);
                                document.getElementById('build-menu').classList.remove('hidden');
                                this.uiVisibility.buildMenu = true;
                                this.updateUIButtonState('toggle-build-menu', 'buildMenu');
                            }
                        });
                    }
                    
                    buildItems.appendChild(itemDiv);
                });
            }

            purchaseUpgrade(type) {
                const upgrade = this.upgradesData[type];
                if (!upgrade) return;
                
                if (this.gameState.credits < upgrade.cost) {
                    this.showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
                    return;
                }
                
                this.gameState.credits -= upgrade.cost;
                this.gameState.upgrades[type] = true;
                
                this.applyUpgrade(type);
                this.updateUI();
                this.updateBuildItems();
                
                this.showNotification(`–£–ª—É—á—à–µ–Ω–∏–µ "${upgrade.name}" –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω–æ!`);
            }

            applyUpgrade(type) {
                switch(type) {
                    case 'skitariiWeapons':
                        this.gameState.units.forEach(unit => {
                            if (unit.userData.type === 'skitarii') {
                                unit.userData.damage = Math.floor(unit.userData.damage * 1.3);
                            }
                        });
                        break;
                    case 'turretRange':
                        this.gameState.units.forEach(unit => {
                            if (unit.userData.type === 'turret') {
                                unit.userData.range = Math.floor(unit.userData.range * 1.4);
                            }
                        });
                        break;
                    case 'dreadnoughtArmor':
                        this.gameState.units.forEach(unit => {
                            if (unit.userData.type === 'dreadnought') {
                                unit.userData.maxHP = Math.floor(unit.userData.maxHP * 1.5);
                                unit.userData.hp = Math.floor(unit.userData.hp * 1.5);
                            }
                        });
                        break;
                }
            }

            startPlacingBuilding(type) {
                this.placingBuilding = type;
                
                if (type === 'wall') {
                    const wallData = this.buildingsData.wall;
                    const geometry = new THREE.BoxGeometry(wallData.size.width, 4, wallData.size.depth);
                    const material = new THREE.MeshBasicMaterial({
                        color: wallData.color,
                        transparent: true,
                        opacity: 0.7
                    });
                    this.placingObject = new THREE.Mesh(geometry, material);
                    this.placingObject.position.y = 2;
                    this.scene.add(this.placingObject);
                } else if (type === 'barracks' || type === 'powerPlant') {
                    const buildingData = this.buildingsData[type];
                    const geometry = new THREE.BoxGeometry(buildingData.size.width, 6, buildingData.size.depth);
                    const material = new THREE.MeshBasicMaterial({
                        color: buildingData.color,
                        transparent: true,
                        opacity: 0.7
                    });
                    this.placingObject = new THREE.Mesh(geometry, material);
                    this.placingObject.position.y = 3;
                    this.scene.add(this.placingObject);
                }
                
                const indicator = document.getElementById('drop-indicator');
                indicator.style.display = 'block';
                indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
            }

            cancelPlacing() {
                if (this.placingObject) {
                    this.scene.remove(this.placingObject);
                    this.placingObject = null;
                }
                this.placingBuilding = null;
                const indicator = document.getElementById('drop-indicator');
                indicator.style.display = 'none';
            }

            placeBuilding(e) {
                if (!this.placingBuilding) return;
                
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    const distanceToBase = intersectionPoint.distanceTo(new THREE.Vector3(0, 0, 0));
                    
                    if (distanceToBase > 30 && distanceToBase < 450) {
                        if (this.placingBuilding === 'wall') {
                            this.createWall(
                                this.placingObject.position.x, 
                                this.placingObject.position.z, 
                                this.placingObject.rotation.y
                            );
                        } else if (this.placingBuilding === 'barracks') {
                            this.createBarracks(intersectionPoint.x, intersectionPoint.z);
                        } else if (this.placingBuilding === 'powerPlant') {
                            this.createPowerPlant(intersectionPoint.x, intersectionPoint.z);
                        } else {
                            this.createUnit(this.placingBuilding, intersectionPoint.x, intersectionPoint.z);
                        }
                        
                        this.scene.remove(this.placingObject);
                        this.placingObject = null;
                        this.placingBuilding = null;
                        
                        const indicator = document.getElementById('drop-indicator');
                        indicator.style.display = 'none';
                    } else {
                        this.showNotification('–ù–µ–ª—å–∑—è —Å—Ç—Ä–æ–∏—Ç—å —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –±–∞–∑–µ –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ!');
                    }
                }
            }

            createUnit(type, x, z) {
                const unitData = this.unitsData[type];
                if (!unitData) return null;
                
                if (this.gameState.credits < unitData.cost) {
                    this.showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
                    return null;
                }
                
                if (this.gameState.currentUnits >= this.gameState.unitLimit) {
                    this.showNotification('–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –≤–æ–π—Å–∫! –ü–æ—Å—Ç—Ä–æ–π—Ç–µ –∫–∞–∑–∞—Ä–º—ã –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞.');
                    return null;
                }
                
                let geometry;
                switch(type) {
                    case 'skitarii':
                        geometry = new THREE.CylinderGeometry(2, 2, 5, 8);
                        break;
                    case 'turret':
                        geometry = new THREE.CylinderGeometry(3, 4, 6, 8);
                        break;
                    case 'dreadnought':
                        geometry = new THREE.BoxGeometry(4, 6, 4);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(3, 3, 3);
                }
                
                const material = new THREE.MeshStandardMaterial({
                    color: unitData.color,
                    metalness: 0.7,
                    roughness: 0.3
                });
                
                const unit = new THREE.Mesh(geometry, material);
                unit.position.set(x, 2, z);
                unit.castShadow = true;
                unit.receiveShadow = true;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è
                let damage = unitData.damage;
                let range = unitData.range;
                let maxHP = unitData.hp;
                
                if (type === 'skitarii' && this.gameState.upgrades.skitariiWeapons) {
                    damage = Math.floor(damage * 1.3);
                }
                if (type === 'turret' && this.gameState.upgrades.turretRange) {
                    range = Math.floor(range * 1.4);
                }
                if (type === 'dreadnought' && this.gameState.upgrades.dreadnoughtArmor) {
                    maxHP = Math.floor(maxHP * 1.5);
                }
                
                unit.userData = {
                    type: type,
                    hp: maxHP,
                    maxHP: maxHP,
                    damage: damage,
                    range: range,
                    attackSpeed: unitData.attackSpeed,
                    speed: unitData.speed,
                    sight: unitData.sight,
                    lastAttack: 0,
                    movable: unitData.movable,
                    target: null,
                    destination: null,
                    rotation: 0,
                    isMoving: false,
                    task: null,
                    patrolIndex: 0,
                    patrolPoints: []
                };
                
                this.scene.add(unit);
                this.gameState.units.push(unit);
                this.gameState.currentUnits++;
                this.gameState.credits -= unitData.cost;
                
                this.updateUI();
                this.createHPBar(unit);
                
                return unit;
            }

            createWall(x, z, rotation = 0) {
                const wallData = this.buildingsData.wall;
                
                if (this.gameState.credits < wallData.cost) {
                    this.showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
                    return;
                }
                
                const geometry = new THREE.BoxGeometry(wallData.size.width, 4, wallData.size.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: wallData.color,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, 2, z);
                wall.rotation.y = rotation;
                wall.castShadow = true;
                wall.receiveShadow = true;
                
                wall.userData = {
                    type: 'wall',
                    hp: wallData.hp,
                    maxHP: wallData.hp,
                    rotation: rotation
                };
                
                this.scene.add(wall);
                this.gameState.walls.push(wall);
                this.gameState.wallsCount++;
                this.gameState.credits -= wallData.cost;
                
                this.updateUI();
                this.createHPBar(wall);
                
                return wall;
            }

            createBarracks(x, z) {
                const barracksData = this.buildingsData.barracks;
                
                if (this.gameState.credits < barracksData.cost) {
                    this.showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
                    return;
                }
                
                const geometry = new THREE.BoxGeometry(barracksData.size.width, 6, barracksData.size.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: barracksData.color,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const barracks = new THREE.Mesh(geometry, material);
                barracks.position.set(x, 3, z);
                barracks.castShadow = true;
                barracks.receiveShadow = true;
                
                barracks.userData = {
                    type: 'barracks',
                    hp: barracksData.hp,
                    maxHP: barracksData.hp
                };
                
                this.scene.add(barracks);
                this.gameState.buildings.push(barracks);
                this.gameState.barracksCount++;
                this.gameState.unitLimit += barracksData.unitLimitIncrease;
                this.gameState.credits -= barracksData.cost;
                
                this.updateUI();
                this.createHPBar(barracks);
                
                return barracks;
            }

            createPowerPlant(x, z) {
                const powerPlantData = this.buildingsData.powerPlant;
                
                if (this.gameState.credits < powerPlantData.cost) {
                    this.showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
                    return;
                }
                
                const geometry = new THREE.BoxGeometry(powerPlantData.size.width, 6, powerPlantData.size.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: powerPlantData.color,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const powerPlant = new THREE.Mesh(geometry, material);
                powerPlant.position.set(x, 3, z);
                powerPlant.castShadow = true;
                powerPlant.receiveShadow = true;
                
                powerPlant.userData = {
                    type: 'powerPlant',
                    hp: powerPlantData.hp,
                    maxHP: powerPlantData.hp
                };
                
                this.scene.add(powerPlant);
                this.gameState.buildings.push(powerPlant);
                this.gameState.powerMax += powerPlantData.powerIncrease;
                this.gameState.credits -= powerPlantData.cost;
                
                this.updateUI();
                this.createHPBar(powerPlant);
                
                return powerPlant;
            }

            createHPBar(object) {
                const hpBar = document.createElement('div');
                hpBar.className = 'hp-bar';
                
                const hpFill = document.createElement('div');
                hpFill.className = 'hp-fill';
                hpBar.appendChild(hpFill);
                
                document.getElementById('game-ui').appendChild(hpBar);
                this.hpBars.set(object, { element: hpBar, fill: hpFill });
            }

            updateHPBar(object) {
                const hpBar = this.hpBars.get(object);
                if (!hpBar || !object.userData) return;
                
                const percent = (object.userData.hp / object.userData.maxHP) * 100;
                hpBar.fill.style.width = percent + '%';
                
                const position = object.position.clone();
                position.y += 5;
                
                const vector = position.project(this.camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                hpBar.element.style.left = (x - 20) + 'px';
                hpBar.element.style.top = (y - 30) + 'px';
                hpBar.element.style.display = 'block';
            }

            selectUnitsInBox(e) {
                const rect = e.target.getBoundingClientRect();
                const x1 = Math.min(this.dragStart.x, e.clientX);
                const x2 = Math.max(this.dragStart.x, e.clientX);
                const y1 = Math.min(this.dragStart.y, e.clientY);
                const y2 = Math.max(this.dragStart.y, e.clientY);
                
                if (this.keys.shift) {
                    // –î–æ–±–∞–≤–ª—è–µ–º –∫ –≤—ã–¥–µ–ª–µ–Ω–∏—é
                } else {
                    this.clearSelection();
                }
                
                this.gameState.units.forEach(unit => {
                    const position = unit.position.clone().project(this.camera);
                    const screenX = (position.x * 0.5 + 0.5) * window.innerWidth;
                    const screenY = (-position.y * 0.5 + 0.5) * window.innerHeight;
                    
                    if (screenX >= x1 && screenX <= x2 && screenY >= y1 && screenY <= y2) {
                        this.selectUnit(unit);
                    }
                });
            }

            clearSelection() {
                this.selectedUnits.forEach(unit => {
                    if (unit.material && unit.material.emissive) {
                        unit.material.emissive.setHex(0x000000);
                    }
                });
                this.selectedUnits = [];
                this.updateSelectionPanel();
            }

            selectObject(object) {
                if (object.userData.type === 'wall' || object.userData.type === 'barracks' || object.userData.type === 'powerPlant') {
                    this.clearSelection();
                    this.selectedUnits.push(object);
                } else {
                    this.selectUnit(object);
                }
                
                if (object.material && object.material.emissive) {
                    object.material.emissive.setHex(0x00ff00);
                    object.material.emissiveIntensity = 0.3;
                }
                
                this.updateSelectionPanel();
            }

            selectUnit(unit) {
                this.selectedUnits.push(unit);
                if (unit.material && unit.material.emissive) {
                    unit.material.emissive.setHex(0x00ff00);
                    unit.material.emissiveIntensity = 0.3;
                }
                
                this.updateSelectionPanel();
            }

            updateSelectionPanel() {
                const panel = document.getElementById('selection-panel');
                panel.innerHTML = '';
                
                if (this.selectedUnits.length === 0) {
                    panel.classList.remove('active');
                    return;
                }
                
                panel.classList.add('active');
                
                this.selectedUnits.slice(0, 8).forEach(unit => {
                    const unitDiv = document.createElement('div');
                    unitDiv.className = 'selected-unit';
                    unitDiv.innerHTML = `
                        <div class="selected-unit-icon">${this.unitsData[unit.userData.type]?.icon || '?'}</div>
                        <div class="selected-unit-hp">${unit.userData.hp}/${unit.userData.maxHP}</div>
                    `;
                    
                    unitDiv.addEventListener('click', () => {
                        this.clearSelection();
                        this.selectUnit(unit);
                    });
                    
                    panel.appendChild(unitDiv);
                });
            }

            saveUnitGroup(index) {
                if (this.selectedUnits.length === 0) return;
                this.unitGroups[index] = [...this.selectedUnits];
                this.showNotification(`–ì—Ä—É–ø–ø–∞ ${index + 1} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ (${this.selectedUnits.length} —é–Ω–∏—Ç–æ–≤)`);
            }

            selectUnitGroup(index) {
                if (!this.unitGroups[index] || this.unitGroups[index].length === 0) return;
                
                this.clearSelection();
                this.unitGroups[index].forEach(unit => {
                    if (unit.userData && unit.userData.hp > 0) {
                        this.selectUnit(unit);
                    }
                });
                
                // –£–¥–∞–ª—è–µ–º –º–µ—Ä—Ç–≤—ã—Ö —é–Ω–∏—Ç–æ–≤ –∏–∑ –≥—Ä—É–ø–ø—ã
                this.unitGroups[index] = this.unitGroups[index].filter(unit => 
                    unit.userData && unit.userData.hp > 0
                );
            }

            startPatrolMode() {
                if (this.selectedUnits.length === 0) return;
                
                this.patrolPoints = [];
                this.showNotification('–†–µ–∂–∏–º –ø–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è: Shift + –ü–ö–ú –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–æ—á–µ–∫, –ü–ö–ú –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è');
            }

            addPatrolPoint(e) {
                if (this.selectedUnits.length === 0) return;
                
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    this.patrolPoints.push(intersectionPoint.clone());
                    
                    this.selectedUnits.forEach(unit => {
                        if (unit.userData.movable) {
                            unit.userData.patrolPoints = [...this.patrolPoints];
                            unit.userData.patrolIndex = 0;
                            unit.userData.task = 'patrol';
                            
                            if (unit.userData.patrolPoints.length > 0) {
                                unit.userData.destination = unit.userData.patrolPoints[0];
                                unit.userData.isMoving = true;
                            }
                        }
                    });
                    
                    this.showNotification(`–¢–æ—á–∫–∞ –ø–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è ${this.patrolPoints.length} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
                }
            }

            moveSelectedUnits(e) {
                if (this.selectedUnits.length === 0) return;
                
                const rect = e.target.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                
                if (this.raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    const distanceToBase = intersectionPoint.distanceTo(new THREE.Vector3(0, 0, 0));
                    
                    if (distanceToBase > 30 && distanceToBase < 450) {
                        this.selectedUnits.forEach(unit => {
                            if (unit.userData.movable) {
                                unit.userData.destination = intersectionPoint.clone();
                                unit.userData.isMoving = true;
                                unit.userData.task = 'move';
                                
                                const offsetX = (Math.random() - 0.5) * 10;
                                const offsetZ = (Math.random() - 0.5) * 10;
                                unit.userData.destination.x += offsetX;
                                unit.userData.destination.z += offsetZ;
                            }
                        });
                        
                        this.createMoveEffect(intersectionPoint);
                    }
                }
            }

            createMoveEffect(position) {
                const ringGeometry = new THREE.RingGeometry(5, 7, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(position.x, 0.5, position.z);
                ring.rotation.x = -Math.PI / 2;
                this.scene.add(ring);
                
                let scale = 1;
                const animate = () => {
                    scale += 0.05;
                    ring.scale.set(scale, scale, scale);
                    ring.material.opacity -= 0.05;
                    
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(ring);
                    }
                };
                animate();
            }

            async startGameplay() {
                return new Promise((resolve) => {
                    document.getElementById('game-screen').style.display = 'block';
                    this.gameState.gameActive = true;
                    
                    this.updateUI();
                    
                    this.startGameLoop();
                    this.startWaves();
                    this.startEconomy();
                    
                    resolve();
                });
            }

            startGameLoop() {
                const animate = () => {
                    if (!this.gameState?.gameActive) return;
                    
                    this.gameState.gameTime++;
                    
                    this.updateCameraMovement();
                    this.updateAnimations();
                    this.updateUnits();
                    this.updateEnemies();
                    this.updateBuildings();
                    this.updateMines();
                    this.updateHPBars();
                    
                    if (this.gameState.baseHP <= 0) {
                        this.endGame();
                        return;
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                    this.gameLoopId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            updateCameraMovement() {
                const moveSpeed = 5;
                const forward = new THREE.Vector3(
                    Math.sin(this.cameraRotation.y),
                    0,
                    Math.cos(this.cameraRotation.y)
                ).normalize();
                
                const right = new THREE.Vector3(
                    Math.cos(this.cameraRotation.y),
                    0,
                    -Math.sin(this.cameraRotation.y)
                ).normalize();
                
                if (this.keys['arrowup']) {
                    this.cameraTarget.add(forward.clone().multiplyScalar(moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['arrowdown']) {
                    this.cameraTarget.add(forward.clone().multiplyScalar(-moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['arrowleft']) {
                    this.cameraTarget.add(right.clone().multiplyScalar(-moveSpeed));
                    this.updateCameraPosition();
                }
                if (this.keys['arrowright']) {
                    this.cameraTarget.add(right.clone().multiplyScalar(moveSpeed));
                    this.updateCameraPosition();
                }
                
                this.cameraTarget.x = Math.max(-400, Math.min(400, this.cameraTarget.x));
                this.cameraTarget.z = Math.max(-400, Math.min(400, this.cameraTarget.z));
            }

            updateAnimations() {
                if (this.core) {
                    const pulse = Math.sin(this.gameState.gameTime * 0.05) * 0.1 + 0.9;
                    this.core.scale.setScalar(pulse);
                }
                
                this.gameState.mines.forEach(mine => {
                    if (mine.drill) {
                        mine.drill.rotation.y += 0.02;
                        if (mine.controlled) {
                            const bounce = Math.sin(this.gameState.gameTime * 0.1 + mine.id) * 2;
                            mine.drill.position.y = 12 + bounce;
                        }
                    }
                });
            }

            updateUnits() {
                for (let i = this.gameState.units.length - 1; i >= 0; i--) {
                    const unit = this.gameState.units[i];
                    
                    if (unit.userData.hp <= 0) {
                        this.scene.remove(unit);
                        this.gameState.units.splice(i, 1);
                        this.gameState.currentUnits--;
                        
                        const hpBar = this.hpBars.get(unit);
                        if (hpBar) {
                            hpBar.element.remove();
                            this.hpBars.delete(unit);
                        }
                        continue;
                    }
                    
                    // –ó–∞—Ö–≤–∞—Ç —à–∞—Ö—Ç
                    if (unit.userData.task === 'capture') {
                        this.captureMines(unit);
                    }
                    
                    // –ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
                    if (unit.userData.task === 'patrol' && unit.userData.patrolPoints.length > 0) {
                        this.updatePatrol(unit);
                    }
                    
                    // –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                    if (unit.userData.isMoving && unit.userData.destination) {
                        const dx = unit.userData.destination.x - unit.position.x;
                        const dz = unit.userData.destination.z - unit.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 2) {
                            const moveDistance = unit.userData.speed;
                            unit.position.x += (dx / distance) * moveDistance;
                            unit.position.z += (dz / distance) * moveDistance;
                            
                            if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                                unit.rotation.y = Math.atan2(dx, dz);
                            }
                        } else {
                            unit.userData.isMoving = false;
                            if (unit.userData.task === 'patrol') {
                                unit.userData.patrolIndex = (unit.userData.patrolIndex + 1) % unit.userData.patrolPoints.length;
                                unit.userData.destination = unit.userData.patrolPoints[unit.userData.patrolIndex];
                                unit.userData.isMoving = true;
                            } else {
                                unit.userData.destination = null;
                                unit.userData.task = null;
                            }
                        }
                    }
                    
                    this.unitAttack(unit);
                }
            }

            captureMines(unit) {
                this.gameState.mines.forEach(mine => {
                    if (!mine.controlled) {
                        const dx = unit.position.x - mine.x;
                        const dz = unit.position.z - mine.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < this.mineCaptureRange) {
                            mine.captureProgress += 0.1;
                            
                            if (mine.captureProgress >= 1) {
                                mine.controlled = true;
                                mine.captureProgress = 1;
                                this.gameState.controlledMines++;
                                this.updateUI();
                                this.showNotification(`–®–∞—Ö—Ç–∞ ${mine.name} –∑–∞—Ö–≤–∞—á–µ–Ω–∞!`);
                            }
                        }
                    }
                });
            }

            updatePatrol(unit) {
                if (!unit.userData.destination && unit.userData.patrolPoints.length > 0) {
                    unit.userData.destination = unit.userData.patrolPoints[0];
                    unit.userData.isMoving = true;
                }
            }

            unitAttack(unit) {
                const currentTime = this.gameState.gameTime;
                const attackCooldown = 60 / unit.userData.attackSpeed;
                
                if (currentTime - unit.userData.lastAttack < attackCooldown) return;
                
                let nearestEnemy = null;
                let nearestDistance = unit.userData.sight;
                
                this.gameState.enemies.forEach(enemy => {
                    const distance = unit.position.distanceTo(enemy.position);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy && nearestDistance <= unit.userData.range) {
                    nearestEnemy.userData.hp -= unit.userData.damage;
                    unit.userData.lastAttack = currentTime;
                    
                    if (nearestEnemy.userData.hp <= 0) {
                        this.gameState.credits += nearestEnemy.userData.bounty;
                        this.gameState.enemiesKilled++;
                        this.gameState.resourcesEarned += nearestEnemy.userData.bounty;
                    }
                    
                    this.createAttackEffect(unit, nearestEnemy);
                }
            }

            updateEnemies() {
                for (let i = this.gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.gameState.enemies[i];
                    
                    if (enemy.userData.hp <= 0) {
                        this.scene.remove(enemy);
                        this.gameState.enemies.splice(i, 1);
                        continue;
                    }
                    
                    let target = null;
                    let targetDistance = enemy.userData.aggressionRange;
                    
                    // –ü–æ–∏—Å–∫ —Ü–µ–ª–∏ –≤ —Ä–∞–¥–∏—É—Å–µ –∞–≥—Ä–µ—Å—Å–∏–∏
                    this.gameState.units.forEach(unit => {
                        const distance = enemy.position.distanceTo(unit.position);
                        if (distance < targetDistance) {
                            targetDistance = distance;
                            target = unit;
                        }
                    });
                    
                    this.gameState.walls.forEach(wall => {
                        const distance = enemy.position.distanceTo(wall.position);
                        if (distance < targetDistance) {
                            targetDistance = distance;
                            target = wall;
                        }
                    });
                    
                    if (target) {
                        const dx = target.position.x - enemy.position.x;
                        const dz = target.position.z - enemy.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > enemy.userData.attackRange) {
                            enemy.position.x += (dx / distance) * enemy.userData.speed;
                            enemy.position.z += (dz / distance) * enemy.userData.speed;
                        } else if (target.userData.type !== 'wall') {
                            const currentTime = this.gameState.gameTime;
                            if (currentTime - enemy.userData.lastAttack >= 60) {
                                target.userData.hp -= enemy.userData.damage;
                                enemy.userData.lastAttack = currentTime;
                                this.createAttackEffect(enemy, target);
                            }
                        }
                        
                        enemy.rotation.y = Math.atan2(dx, dz);
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –±–∞–∑–µ
                        const dx = 0 - enemy.position.x;
                        const dz = 0 - enemy.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 15) {
                            enemy.position.x += (dx / distance) * enemy.userData.speed;
                            enemy.position.z += (dz / distance) * enemy.userData.speed;
                            enemy.rotation.y = Math.atan2(dx, dz);
                        } else {
                            this.gameState.baseHP -= enemy.userData.damage;
                            this.createDamageEffect(0, 20, 0);
                            this.updateUI();
                        }
                    }
                }
            }

            updateBuildings() {
                this.gameState.walls.forEach(wall => {
                    if (wall.userData.hp <= 0) {
                        this.scene.remove(wall);
                        this.gameState.walls = this.gameState.walls.filter(w => w !== wall);
                        this.gameState.wallsCount--;
                        
                        const hpBar = this.hpBars.get(wall);
                        if (hpBar) {
                            hpBar.element.remove();
                            this.hpBars.delete(wall);
                        }
                    }
                });
            }

            updateMines() {
                this.gameState.mines.forEach(mine => {
                    const element = document.getElementById(`mine-${mine.id + 1}`);
                    if (element) {
                        if (mine.controlled) {
                            element.textContent = `–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç—Å—è ${Math.floor(mine.captureProgress * 100)}%`;
                            element.style.color = '#00ff00';
                        } else {
                            element.textContent = '–°–≤–æ–±–æ–¥–Ω–∞';
                            element.style.color = '#fff';
                        }
                    }
                });
            }

            updateHPBars() {
                [...this.gameState.units, ...this.gameState.walls, ...this.gameState.buildings, ...this.gameState.enemies].forEach(obj => {
                    this.updateHPBar(obj);
                });
            }

            createAttackEffect(attacker, target) {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    attacker.position.clone(),
                    target.position.clone()
                ]);
                
                const material = new THREE.LineBasicMaterial({
                    color: attacker.userData.type === 'turret' ? 0xffd700 : 
                           attacker.userData.type === 'basic' ? 0x00ff00 :
                           attacker.userData.type === 'heavy' ? 0xff8800 : 0xff0000,
                    transparent: true,
                    opacity: 0.6
                });
                
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                
                setTimeout(() => this.scene.remove(line), 100);
            }

            createDamageEffect(x, y, z) {
                const geometry = new THREE.SphereGeometry(5, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                this.scene.add(sphere);
                
                let scale = 1;
                const animate = () => {
                    scale += 0.1;
                    sphere.scale.setScalar(scale);
                    sphere.material.opacity -= 0.05;
                    
                    if (sphere.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(sphere);
                    }
                };
                animate();
            }

            showNotification(message, duration = 3000) {
                this.notification.textContent = message;
                this.notification.style.display = 'block';
                
                setTimeout(() => {
                    this.notification.style.display = 'none';
                }, duration);
            }

            startWaves() {
                setTimeout(() => this.spawnWave(), 10000);
                
                this.waveInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    this.gameState.currentWave++;
                    this.gameState.waveTimer = 60;
                    this.spawnWave();
                    
                }, 60000);
                
                this.waveTimerInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    if (this.gameState.waveTimer > 0) {
                        this.gameState.waveTimer--;
                        document.getElementById('wave-timer').textContent = this.gameState.waveTimer;
                    }
                }, 1000);
            }

            spawnWave() {
                const enemyCount = 3 + Math.floor(this.gameState.currentWave * 1.5);
                const heavyCount = Math.floor(this.gameState.currentWave / 3);
                const bossCount = this.gameState.currentWave % 5 === 0 ? 1 : 0;
                
                let spawned = 0;
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (!this.gameState?.gameActive) return;
                        
                        let type = 'basic';
                        if (spawned < heavyCount) {
                            type = 'heavy';
                        }
                        if (bossCount > 0 && spawned === enemyCount - 1) {
                            type = 'boss';
                            this.showNotification('–ë–û–°–° –ü–†–ò–ë–´–í–ê–ï–¢!');
                        }
                        
                        this.spawnEnemy(type);
                        spawned++;
                    }, i * 800);
                }
                
                document.getElementById('wave').textContent = this.gameState.currentWave;
                this.showNotification(`–í–æ–ª–Ω–∞ ${this.gameState.currentWave}!`);
            }

            spawnEnemy(type) {
                const enemyType = this.enemyData[type] || this.enemyData.basic;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 480;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const geometry = new THREE.BoxGeometry(4, 5, 4);
                const material = new THREE.MeshStandardMaterial({
                    color: enemyType.color,
                    metalness: 0.5,
                    roughness: 0.5
                });
                
                const enemy = new THREE.Mesh(geometry, material);
                enemy.position.set(x, 2.5, z);
                enemy.castShadow = true;
                
                enemy.userData = {
                    type: type,
                    hp: enemyType.hp,
                    maxHP: enemyType.hp,
                    damage: enemyType.damage,
                    speed: enemyType.speed,
                    sight: enemyType.sight,
                    attackRange: enemyType.attackRange,
                    aggressionRange: enemyType.aggressionRange,
                    bounty: enemyType.bounty,
                    lastAttack: 0
                };
                
                this.scene.add(enemy);
                this.gameState.enemies.push(enemy);
                
                this.createHPBar(enemy);
            }

            startEconomy() {
                this.economyInterval = setInterval(() => {
                    if (!this.gameState?.gameActive) return;
                    
                    const income = this.gameState.controlledMines * this.gameState.mineIncome;
                    this.gameState.credits += income;
                    this.gameState.resourcesEarned += income;
                    
                    this.gameState.power = Math.min(
                        this.gameState.powerMax,
                        this.gameState.power + 10
                    );
                    
                    document.getElementById('requisition').textContent = 
                        `+${this.gameState.controlledMines * this.gameState.mineIncome}/–º–∏–Ω`;
                    
                    this.updateUI();
                    
                }, 10000);
            }

            updateUI() {
                document.getElementById('credits').textContent = this.gameState.credits;
                document.getElementById('power').textContent = 
                    `${this.gameState.power}/${this.gameState.powerMax}`;
                document.getElementById('base-hp').textContent = this.gameState.baseHP;
                document.getElementById('unit-limit').textContent = 
                    `${this.gameState.currentUnits}/${this.gameState.unitLimit}`;
                document.getElementById('barracks-count').textContent = this.gameState.barracksCount;
                document.getElementById('walls-count').textContent = this.gameState.wallsCount;
                
                this.updateBuildItems();
            }

            onWindowResize() {
                if (!this.camera || !this.renderer) return;
                
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            endGame() {
                this.gameState.gameActive = false;
                
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                    this.gameLoopId = null;
                }
                if (this.waveInterval) clearInterval(this.waveInterval);
                if (this.economyInterval) clearInterval(this.economyInterval);
                if (this.waveTimerInterval) clearInterval(this.waveTimerInterval);
                
                document.getElementById('survived-waves').textContent = this.gameState.currentWave;
                document.getElementById('enemies-killed').textContent = this.gameState.enemiesKilled;
                document.getElementById('resources-earned').textContent = this.gameState.resourcesEarned;
                
                document.getElementById('game-over').style.display = 'block';
            }
        }

        window.addEventListener('load', () => {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">–û–®–ò–ë–ö–ê –í–ï–ë-–ì–†–ê–§–ò–ö–ò</h2>
                    <p style="margin-bottom: 20px;">–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç WebGL. –ò–≥—Ä–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–ø—É—â–µ–Ω–∞.</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">–ü–û–ü–†–û–ë–û–í–ê–¢–¨ –°–ù–û–í–ê</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
                return;
            }
            
            Game.start().catch(error => {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(0,0,0,0.9)';
                errorDiv.style.color = '#ff4500';
                errorDiv.style.padding = '30px';
                errorDiv.style.borderRadius = '10px';
                errorDiv.style.border = '2px solid #ff4500';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h2 style="margin-bottom: 20px;">–û–®–ò–ë–ö–ê –ó–ê–ì–†–£–ó–ö–ò</h2>
                    <p style="margin-bottom: 20px;">–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–≥—Ä—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.</p>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(45deg, #ff4500, #ff8800);
                        border: none;
                        color: white;
                        padding: 10px 20px;
                        cursor: pointer;
                        border-radius: 5px;
                    ">–û–ë–ù–û–í–ò–¢–¨ –°–¢–†–ê–ù–ò–¶–£</button>
                `;
                document.getElementById('game-container').appendChild(errorDiv);
            });
        });
    </script>
</body>
</html>
